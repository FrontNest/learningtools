,Main,Topics,Description,Codes,1
,printing,printing,"Let's start off by creating a short program that displays ""Hello world!"".
In Python, we use the print statement to output text. 
Note that the text should be enclosed into single or double quotes. 
The print statement needs to be followed by parentheses, which enclose the output we want to generate.
The print statement can also be used to output multiple lines of text.
Each print statement outputs text from a new line.
Python code often contains references to the comedy group Monty Python. 
This is why the words, ""spam"" and ""eggs"" are often used as placeholder variables in Python.",print('Hello world!'),2
,simple operations,simple operations,"Simple Operations
Python has the capability of carrying out calculations.
Enter a calculation directly into the print statement:
print(2 + 2)
print(5 + 4 - 3)
The spaces around the plus and minus signs here are optional 
(the code would work without them), but they make it easier to read.
Python also carries out multiplication and division, using an asterisk * to indicate multiplication and a forward slash / to indicate division.
Use parentheses to determine which operations are performed first.
Using a single slash to divide numbers produces a decimal (or float, as it is called in programming). We'll have more about floats in the next lesson.","print(2 + 2)
print(5 + 4 - 3)",3
,floats,floats,"Floats are used in Python to represent numbers that aren't integers (whole numbers).
Some examples of numbers that are represented as floats are 0.5 and -7.8237591.
They can be created directly by entering a number with a decimal point, or by using operations such as division on integers.  Computers can't store floats perfectly accurately, in the same way that we can't write down the complete decimal expansion of 1/3 (0.3333333333333333...). Keep this in mind, because it often leads to infuriating bugs!     A float is also produced by running an operation on two floats, or on a float and an integer.  A float can be added to an integer, because Python silently converts the integer to a float.","print( 3/4 )
print( 0.42 )
print( 8 / 2 )
print( 6 * 7.0 )
print( 4 + 1.65 )",4
,Exponentiation,Exponentiation **,"Besides addition, subtraction, multiplication, and division, Python also supports exponentiation, which is the raising of one number to the power of another. This operation is performed using two asterisks.
You can chain exponentiations together. In other words, you can rise a number to multiple powers. For example, 2**3**2.
You can also use floats in exponentiation. Note that the result will be a float.",print(2**5),5
,Quotient,Quotient //,"Floor division is done using two forward slashes and is used to determine the quotient of a division (the quantity produced by the division of two numbers).
You can also use floor division on floats.","print( 20 // 6 ) 
# The code above will output 3, because 6 goes into 20 three times.",6
,Remainder,Remainder %,"The modulo operator is carried out with a percent symbol (%) and is used to get the remainder of a division.
All numerical operators can also be used with floats.","print(20 % 6)
print(1.25 % 0.5)",7
,Strings,"Strings """" ''","If you want to use text in Python, you have to use a string.
A string is created by entering text between two single or double quotation marks.
The delimiter ("" or ') used for a string doesn't affect how it behaves in any way.","print('Coding in Finance')
print(""An investment in knowledge pays the best interest."")",8
,Backslash,Backslash \,"Some characters can't be directly included in a string. For instance, double quotes can't be directly included in a double quote string; this would cause it to end prematurely.

Characters like these must be escaped by placing a backslash before them.
Double quotes only need to be escaped in double quote strings, and the same is true for single quote strings.
Backslashes can also be used to escape tabs, arbitrary Unicode characters, and various other things that can't be reliably printed.",print('Brian\'s mother: He\'s not an angel. He\'s a very naughty boy!'),9
,Newlines,"Newlines \n \t """"""","\n represents a new line.
It can be used in strings to create multi-line output:
Similarly, \t represents a tab.
Newlines will be automatically added for strings that are created using three quotes.
This makes it easier to format long, multi-line texts without the need to explicitly put \n for line breaks.","print('One\nTwo\nThree')
print(""""""this
is a
multiline
text"""""")",10
,Concatenation,Concatenation,"As with integers and floats, strings in Python can be added, using a process called concatenation, which can be done on any two strings.
Even if your strings contain numbers, they are still added as strings rather than integers.
Adding a string to a number produces an error, as even though they might look similar, they are two different entities.
Strings can also be multiplied by integers. This produces a repeated version of the original string. The order of the string and the integer doesn't matter, but the string usually comes first.
Strings can't be multiplied by other strings. Strings also can't be multiplied by floats, even if the floats are whole numbers.","print(""Spam"" + 'eggs')
print(""2"" + ""2"")
print(""spam"" * 3)
print(4 * '2')",11
,Variables,Variables,"A variable allows you to store a value by assigning it to a name, which can be used to refer to the value later in the program.
For example, in game development, you would use a variable to store the points of the player.

To assign a variable, use one equals sign.
In given example we assigned string ""James"" to user variable.

Certain restrictions apply in regard to the characters that may be used in Python variable names. The only characters that are allowed are letters, numbers, and underscores. Also, they can't start with numbers.
Not following these rules results in errors.

Python is a case sensitive programming language. Thus, Lastname and lastname are two different variable names in Python.

You can use variables to perform corresponding operations, just as you did with numbers and strings.
As you can see, the variable stores its value throughout the program.

Variables can be reassigned as many times as you want, in order to change their value.
In Python, variables don't have specific types, so you can assign a string to a variable, and later assign an integer to the same variable.
However, it is not good practice. To avoid mistakes, try to avoid overwriting the same variable with different data types.","user = ""James""

x = 7
print(x)
print(x + 3)
print(x)

x = 123.456
print(x)
x = ""This is a string""
print(x + ""!"")",12
,Input,Input,"To get input from the user in Python, you can use the intuitively named input function.
For example, a game can ask for the user's name and age as input and use them in the game.

The input function prompts the user for input, and returns what they enter as a string (with the contents automatically escaped).
Even if the user enters a number as input, it is processed as a string.

The input statement needs to be followed by parentheses.
You can provide a string to input() between the parentheses, producing a prompt message.

The prompt message helps to clarify what input the program is asking for.

Let's assume we want to take the age of the user as input.
We know that the input() function returns a string.
To convert it to a number, we can use the int() function:

Similarly, in order to convert a number to a string, the str() function is used. This can be useful if you need to use a number in string concatenation.

You can convert to float using the float() function.

You can use input() multiple times to take multiple user inputs.
When input() function executes, program flow stops until a user enters some value.","x = input()
print(x)

name = input(""Enter your name: "")
print(""Hello, "" + name) 

age = int(input())
print(age) 

age = 42
print(""His age is "" + str(age))  

name = input()
age = input()
print(name + "" is "" + age) ",13
,In-Place Operators,In-Place Operators,"To get input from the user in Python, you can use the intuitively named input function.
For example, a game can ask for the user's name and age as input and use them in the game.

The input function prompts the user for input, and returns what they enter as a string (with the contents automatically escaped).
In-place operators allow you to write code like 'x = x + 3' more concisely, as 'x += 3'.
The same thing is possible with other operators such as -, *, / and % as well.

These operators can be used on types other than numbers, as well, such as strings.
In-place operators can be used for any numerical operation (+, -, *, /, %, **, //).

Walrus operator := allows you to assign values to variables within an expression, including variables that do not exist yet.
The walrus operator accomplishes these operations at once: print(num:=int(input()))
The walrus operator makes code more readable and can be useful in many situations.","x = 2
print(x)

x += 3
print(x)

x = ""spam""
print(x)

x += ""eggs""
print(x)

num = int(input())
print(num)

print(num:=int(input()))",14
,Booleans,Booleans True False == !== < >,"Another type in Python is the Boolean type. There are two Boolean values: True and False.
They can be created by comparing values, for instance by using the equal operator ==.
Be careful not to confuse assignment (one equals sign) with comparison (two equals signs).

Another comparison operator, the not equal operator (!=), evaluates to True if the items being compared aren't equal, and False if they are. Comparison operators are also called Relational operators.
Python also has operators that determine whether one number (float or integer) is greater than or smaller than another. These operators are > and < respectively.
Different numeric types can also be compared, for example, integer and float.

The greater than or equal to, and smaller than or equal to operators are >= and <=.
They are the same as the strict greater than and smaller than operators, except that they return True when comparing equal numbers.

Greater than and smaller than operators can also be used to compare strings lexicographically (the alphabetical order of words is based on the alphabetical order of their component letters).
The first characters from ""Annie"" and ""Andy"" (A and A) are compared. As they are equal, the second two characters are compared. Because they are also equal, the third two characters (n and d) are compared. And because n has greater alphabetical order value than d, ""Annie"" is greater than ""Andy"".","my_boolean = True
print(my_boolean)
print(2 == 3)
print(""hello"" == ""hello"")

print(1 != 1)
print(""eleven"" != ""seven"")
print(2 != 10)

print(7 > 5)
print(10 < 10)

print(7 <= 8)
True
print(9 >= 9.0)
True

print(""Annie"" > ""Andy"")
True",15
,if Statements,if Statements,"Another type in Python is the Boolean type. There are two Boolean values: True and False.
You can use if statements to run code if a certain condition holds.
If an expression evaluates to True, some statements are carried out. Otherwise, they aren't carried out.
An if statement looks like this:
if expression:
   statements

Python uses indentation (white space at the beginning of a line) to delimit blocks of code. Depending on program's logic, indentation can be mandatory. As you can see, the statements in the if should be indented.
The expression determines whether 10 is greater than 5. Since it is, the indented statement runs, and ""10 greater than 5"" is output. Then, the unindented statement, which is not part of the if statement, is run, and ""Program ended"" is displayed.
Notice the colon at the end of the expression in the if statement.

To perform more complex checks, if statements can be nested, one inside the other.
This means that the inner if statement is the statement part of the outer one. This is one way to see whether multiple conditions are satisfied.

Indentation is used to define the level of nesting.","if 10 > 5:
    print(""10 greater than 5"")
print(""Program ended"")

num = 12
if num > 5:
    print(""Bigger than 5"")
    if num <=47:
        print(""Between 5 and 47"")",16
,else Statements,else elif,"The if statement allows you to check a condition and run some statements, if the condition is True.
The else statement can be used to run some statements when the condition of the if statement is False.

As with if statements, the code inside the block should be indented.
Notice the colon after the else keyword.

Every if condition block can have only one else statement.
In order to make multiple checks, you can chain if and else statements.

For example, the following program checks and outputs the num variable's value as text:
num = 3
if num == 1:
    print(""One"")
else: 
    if num == 2:
        print(""Two"")
    else: 
        if num == 3: 
            print(""Three"")
        else: 
            print(""Something else"")

Indentation determines which if/else statements the code blocks belong to.

Multiple if/else statements make the code long and not very readable.
The elif (short for else if) statement is a shortcut to use when chaining if and else statements, making the code shorter.

The same example from the previous part can be rewritten using elif statements:
num = 3
if num == 1:
    print(""One"")
elif num == 2:
    print(""Two"")
elif num == 3: 
    print(""Three"")
else: 
    print(""Something else"")

As you can see in the example above, a series of if elif statements can have a final else block, which is called if none of the if or elif expressions is True.
The elif statement is equivalent to an else/if statement. It is used to make the code shorter, more readable, and avoid indentation increase.","num = 3
if num == 1:
    print(""One"")
else: 
    if num == 2:
        print(""Two"")
    else: 
        if num == 3: 
            print(""Three"")
        else: 
            print(""Something else"")

num = 3
if num == 1:
    print(""One"")
elif num == 2:
    print(""Two"")
elif num == 3: 
    print(""Three"")
else: 
    print(""Something else"")

x = 4
if x == 5:
    print(""Yes"")
else:
    print(""No"")",17
,Boolean Logic,Boolean Logic,"Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition.
Python's Boolean operators are and, or, and not.
The and operator takes two arguments, and evaluates as True if, and only if, both of its arguments are True. Otherwise, it evaluates to False.
Boolean operators can be used in expression as many times as needed.

The or operator also takes two arguments. It evaluates to True if either (or both) of its arguments are True, and False if both arguments are False.
Besides values, you can also compare variables.

Unlike other operators we've seen so far, not only takes one argument, and inverts it.
The result of not True is False, and not False goes to True.

You can chain multiple conditional statements in an if statement using the Boolean operators.","print(1 == 1 and 2 == 2)
print(1 == 1 and 2 == 3)
print(1 != 1 and 2 == 2)
print(2 < 1 and 3 > 6)

print(1 == 1 or 2 == 3)
print(1 != 1 or 2 == 2)
print(2 < 1 or 3 >  6)

print(not 1 == 1)
print(not 1 > 7)",18
,Operator Precedence,Operator Precedence,"Operator precedence is a very important concept in programming. It is an extension of the mathematical idea of order of operations (multiplication being performed before addition, etc.) to include other operators, such as those in Boolean logic.

The below code shows that == has a higher precedence than or:
Python's order of operations is the same as that of normal mathematics: parentheses first, then exponentiation, then multiplication/division, and then addition/subtraction.","print(False == False or True)
print(False == (False or True))
print((False == False) or True)",19
,Chaining Multiple Conditions,Chaining Multiple Conditions,"You can chain multiple conditional statements in an if statement using the Boolean operators.

For example, we can check if the value of a grade is between 70 and 100:
You can use multiple and, or, not operators to chain multiple conditions together.","grade = 88
if(grade >= 70 and grade <= 100):
    print(""Passed!"")",20
,Lists,Lists,"Lists are used to store items.
A list is created using square brackets with commas separating items.
words = [""Hello"", ""world"", ""!""]

In the example above the words list contains three string items.
A certain item in the list can be accessed by using its index in square brackets.

For example:
words = [""Hello"", ""world"", ""!""]
print(words[0])
print(words[1])
print(words[2]) 

The first list item's index is 0, rather than 1, as might be expected.

Sometimes you need to create an empty list and populate it later during the program. For example, if you are creating a queue management program, the queue is going to be empty in the beginning and get populated with people data later.

An empty list is created with an empty pair of square brackets.
empty_list = []
print(empty_list)

In some code samples you might see a comma after the last item in the list. It's not mandatory, but perfectly valid.

Typically, a list will contain items of a single item type, but it is also possible to include several different types.
Lists can also be nested within other lists. 
number = 3
things = [""string"", 0, [1, 2, number], 4.56]
print(things[1])
print(things[2])
print(things[2][2])

Nested lists can be used to represent 2D grids, such as matrices.
m = [
    [1,2,3],
    [4,5,6]
    ]
    
print(m[1][2]) 

A matrix-like structure can be used in cases where you need to store data in row-column format. For example, when creating a ticketing program, the seat numbers can be stored in a matrix, with their corresponding rows and numbers.
The code above outputs the 3rd item of the 2nd row.

Some types, such as strings, can be indexed like lists.
Indexing strings behaves as though you are indexing a list containing each character in the string.

For example:
str = ""Hello world!""
print(str[6])

Space ("" "") is also a symbol and has an index.
Trying to access a non-existing index will produce an error.


","words = [""Hello"", ""world"", ""!""]

words = [""Hello"", ""world"", ""!""]
print(words[0])
print(words[1])
print(words[2]) 

empty_list = []
print(empty_list)
 
number = 3
things = [""string"", 0, [1, 2, number], 4.56]
print(things[1])
print(things[2])
print(things[2][2])

m = [
    [1,2,3],
    [4,5,6]
    ]
    
print(m[1][2]) 

str = ""Hello world!""
print(str[6])",21
,List Operations,List Operations,"The item at a certain index in a list can be reassigned.
nums = [7, 7, 7, 7, 7]
nums[2] = 5
print(nums)
You can replace the item with an item of a different type.

Lists can be added and multiplied in the same way as strings.
nums = [1, 2, 3]
print(nums + [4, 5, 6])
print(nums * 3)

Lists and strings are similar in many ways - strings can be thought of as lists of characters that can't be changed.
For example, the string ""Hello"" can be thought of as a list, where each character is an item in the list. The first item is ""H"", the second item is ""e"", and so on.

To check if an item is in a list, the in operator can be used.
It returns True if the item occurs one or more times in the list, and False if it doesn't.

words = [""spam"", ""egg"", ""spam"", ""sausage""]
print(""spam"" in words)
print(""egg"" in words)
print(""tomato"" in words)

The in operator is also used to determine whether or not a string is a substring of another string.

To check if an item is not in a list, you can use the not operator in one of the following ways:
nums = [1, 2, 3]
print(not 4 in nums)
print(4 not in nums)
print(not 3 in nums)
print(3 not in nums)","nums = [7, 7, 7, 7, 7]
nums[2] = 5
print(nums)

nums = [1, 2, 3]
print(nums + [4, 5, 6])
print(nums * 3)

words = [""spam"", ""egg"", ""spam"", ""sausage""]
print(""spam"" in words)
print(""egg"" in words)
print(""tomato"" in words)

nums = [1, 2, 3]
print(not 4 in nums)
print(4 not in nums)
print(not 3 in nums)
print(3 not in nums)",22
,List Functions,List Functions len insert,"The append method adds an item to the end of an existing list.
nums = [1, 2, 3]
nums.append(4)
print(nums)

The dot before append is there because it is a method of the list class. Methods will be explained in a later lesson.

To get the number of items in a list, you can use the len function.
Unlike the index of the items, len does not start with 0. So, the list above contains 5 items, meaning len will return 5.

len is written before the list it is being called on, without a dot.
nums = [1, 3, 5, 2, 4]
print(len(nums))

The insert method is similar to append, except that it allows you to insert a new item at any position in the list, as opposed to just at the end.
words = [""Python"", ""fun""]
index = 1
words.insert(index, ""is"")
print(words)

Elements, that are after the inserted item, are shifted to the right.

The index method finds the first occurrence of a list item and returns its index.
If the item isn't in the list, it raises a ValueError.
letters = ['p', 'q', 'r', 's', 'p', 'u']
print(letters.index('r'))
print(letters.index('p'))
print(letters.index('z'))

There are a few more useful functions and methods for lists.
max(list): Returns the list item with the maximum value
min(list): Returns the list item with minimum value
list.count(item): Returns a count of how many times an item occurs in a list
list.remove(item): Removes an object from a list
list.reverse(): Reverses items in a list.

For example, you can count how many 42s are there in the list using:
items.count(42)
where items is the name of our list.","nums = [1, 2, 3]
nums.append(4)
print(nums)

nums = [1, 3, 5, 2, 4]
print(len(nums))

words = [""Python"", ""fun""]
index = 1
words.insert(index, ""is"")
print(words)

letters = ['p', 'q', 'r', 's', 'p', 'u']
print(letters.index('r'))
print(letters.index('p'))
print(letters.index('z'))

items.count(42)",23
,while Loops,while Loops,"A while loop is used to repeat a block of code multiple times.
For example, let's say we need to process multiple user inputs, so that each time the user inputs something, the same block of code needs to execute.

Below is a while loop containing a variable that counts up from 1 to 5, at which point the loop terminates.

i = 1
while i <=5:
    print(i)
    i = i + 1

print(""Finished!"")

During each loop iteration, the i variable will get incremented by one, until it reaches 5.
So, the loop will execute the print statement 5 times.

The code in the body of a while loop is executed repeatedly. This is called iteration.

You can use multiple statements in the while loop.

For example, you can use an if statement to make decisions. This can be useful, if you are making a game and need to loop through a number of player actions and add or remove points of the player.

The code below uses an if/else statement inside a while loop to separate the even and odd numbers in the range of 1 to 10:
x = 1
while x < 10:
    if x%2 == 0:
        print(str(x) + "" is even"")
    else:
        print(str(x) + "" is odd"")

    x += 1 

str(x) is used to convert the number x to a string, so that it can be used for concatenation.

In console, you can stop the program's execution by using the Ctrl-C shortcut or by closing the program.

To end a while loop prematurely, the break statement can be used.
For example, we can break an infinite loop if some condition is met:
i = 0
while 1==1:
    print(i)
    i = i + 1
    if i >= 5:
        print(""Breaking"")
        break

print(""Finished"")

while True is a short and easy way to make an infinite loop.

An example use case of break:
An infinite while loop can be used to continuously take user input. For example, you are making a calculator and need to take numbers from the user to add and stop, when the user enters ""stop"".
In this case, the break statement can be used to end the infinite loop when the user input equals ""stop"".

Using the break statement outside of a loop causes an error.

Another statement that can be used within loops is continue.
Unlike break, continue jumps back to the top of the loop, rather than stopping it. Basically, the continue statement stops the current iteration and continues with the next one.

For example:
i = 0
while i<5:
  i += 1
  if i==3:
    print(""Skipping 3"")
    continue
  print(i)

An example use case of continue:
An airline ticketing system needs to calculate the total cost for all tickets purchased. The tickets for children under the age of 1 are free. We can use a while loop to iterate through the list of passengers and calculate the total cost of their tickets. Here, the continue statement can be used to skip the children.

Using the continue statement outside of a loop causes an error.






","i = 1
while i <=5:
    print(i)
    i = i + 1

print(""Finished!"")


x = 1
while x < 10:
    if x%2 == 0:
        print(str(x) + "" is even"")
    else:
        print(str(x) + "" is odd"")

    x += 1 

i = 0
while 1==1:
    print(i)
    i = i + 1
    if i >= 5:
        print(""Breaking"")
        break

print(""Finished"")

i = 0
while i<5:
  i += 1
  if i==3:
    print(""Skipping 3"")
    continue
  print(i)",24
,for Loops,for Loops,"The for loop is used to iterate over a given sequence, such as lists or strings.

The code below outputs each item in the list and adds an exclamation mark at the end:
words = [""hello"", ""world"", ""spam"", ""eggs""]
for word in words:
    print(word + ""!"")

In the code above, the word variable represents the corresponding item of the list in each iteration of the loop.
During the 1st iteration, word is equal to ""hello"", and during the 2nd iteration it's equal to ""world"", and so on.

The for loop can be used to iterate over strings.

For example:
str = ""testing for loops""
count = 0

for x in str:
   if(x == 't'):
    count += 1

print(count)

The code above defines a count variable, iterates over the string and calculates the count of 't' letters in it. During each iteration, the x variable represents the current letter of the string.
The count variable is incremented each time the letter 't' is found, thus, at the end of the loop it represents the number of 't' letters in the string.

Similar to while loops, the break and continue statements can be used in for loops, to stop the loop or jump to the next iteration.

Both, for and while loops can be used to execute a block of code for multiple times.

It is common to use the for loop when the number of iterations is fixed. For example, iterating over a fixed list of items in a shopping list.

The while loop is used in cases when the number of iterations is not known and depends on some calculations and conditions in the code block of the loop.
For example, ending the loop when the user enters a specific input in a calculator program.

Both, for and while loops can be used to achieve the same results, however, the for loop has cleaner and shorter syntax, making it a better choice in most cases.













","words = [""hello"", ""world"", ""spam"", ""eggs""]
for word in words:
    print(word + ""!"")

str = ""testing for loops""
count = 0

for x in str:
   if(x == 't'):
    count += 1

print(count)",25
,Range,Range,"The range() function returns a sequence of numbers.
By default, it starts from 0, increments by 1 and stops before the specified number.

The code below generates a list containing all of the integers, up to 10.
numbers = list(range(10))
print(numbers)

In order to output the range as a list, we need to explicitly convert it to a list, using the list() function.

If range is called with one argument, it produces an object with values from 0 to that argument.
If it is called with two arguments, it produces values from the first to the second.

For example:
numbers = list(range(3, 8))
print(numbers)
print(range(20) == range(0, 20))

Remember, the second argument is not included in the range, so range(3, 8) will not include the number 8.

range can have a third argument, which determines the interval of the sequence produced, also called the step.
numbers = list(range(5, 20, 2))
print(numbers)

We can also create list of decreasing numbers, using a negative number as the third argument, for example list(range(20, 5, -2)).

The for loop is commonly used to repeat some code a certain number of times. This is done by combining for loops with range objects.
for i in range(5):
    print(""hello!"")

You don't need to call list on the range object when it is used in a for loop, because it isn't being indexed, so a list isn't required.","numbers = list(range(10))
print(numbers)

numbers = list(range(3, 8))
print(numbers)
print(range(20) == range(0, 20))

numbers = list(range(5, 20, 2))
print(numbers)

for i in range(5):
    print(""hello!"")",26
,Reusing Code,Reusing Code,"Code reuse is a very important part of programming in any language. Increasing code size makes it harder to maintain.
For a large programming project to be successful, it is essential to abide by the Don't Repeat Yourself, or DRY, principle. We've already looked at one way of doing this: by using loops. In this module, we will explore two more: functions and modules.

Bad, repetitive code is said to abide by the WET principle, which stands for Write Everything Twice, or We Enjoy Typing.

You've already used functions in previous lessons.
Any statement that consists of a word followed by information in parentheses is a function call.
Here are some examples that you've already seen:
print(""Hello world!"")
range(2, 20)
str(12)
range(10, 20, 3)

The words in front of the parentheses are function names, and the comma-separated values inside the parentheses are function arguments.","print(""Hello world!"")
range(2, 20)
str(12)
range(10, 20, 3)",27
,Functions,Functions,"In addition to using pre-defined functions, you can create your own functions by using the def statement.
Here is an example of a function named my_func. It takes no arguments, and prints ""spam"" three times. It is defined, and then called. The statements in the function are executed only when the function is called.
def my_func():
    print(""spam"")
    print(""spam"")
    print(""spam"")

my_func()

The code block within every function starts with a colon (:) and is indented.
You must define functions before they are called, in the same way that you must assign variables before using them.
hello()

def hello():
    print(""Hello world!"")","def my_func():
    print(""spam"")
    print(""spam"")
    print(""spam"")

my_func()

hello()

def hello():
    print(""Hello world!"")",28
,Arguments,Arguments,"All the function definitions we've looked at so far have been functions of zero arguments, which are called with empty parentheses.
However, most functions take arguments.
The example below defines a function that takes one argument:

def print_with_exclamation(word):
   print(word + ""!"")
    
print_with_exclamation(""spam"")
print_with_exclamation(""eggs"")
print_with_exclamation(""python"")

As you can see, the argument is defined inside the parentheses.
You can also define functions with more than one argument; separate them with commas.

def print_sum_twice(x, y):
   print(x + y)
   print(x + y)

print_sum_twice(5, 8)

Function arguments can be used as variables inside the function definition. However, they cannot be referenced outside of the function's definition. This also applies to other variables created inside a function.

def function(variable):
    variable += 1
    print(variable)

function(7)
print(variable)

This code will throw an error because the variable is defined inside the function and can be referenced only there.

Technically, parameters are the variables in a function definition, and arguments are the values put into parameters when functions are called.

","def print_with_exclamation(word):
   print(word + ""!"")
    
print_with_exclamation(""spam"")
print_with_exclamation(""eggs"")
print_with_exclamation(""python"")


def print_sum_twice(x, y):
   print(x + y)
   print(x + y)

print_sum_twice(5, 8)


def function(variable):
    variable += 1
    print(variable)

function(7)
print(variable)",29
,Returning from Functions,Returning from Functions,"Certain functions, such as int or str, return a value that can be used later.
To do this for your defined functions, you can use the return statement.

For example:
def max(x, y):
    if x >=y:
        return x
    else:
        return y
        
print(max(4, 7))
z = max(8, 5)
print(z)

The return statement cannot be used outside of a function definition.

Once you return a value from a function, it immediately stops being executed. Any code after the return statement will never happen.

For example:
def add_numbers(x, y):
    total = x + y
    return total
    print(""This won't be printed"")

print(add_numbers(4, 5))","def max(x, y):
    if x >=y:
        return x
    else:
        return y
        
print(max(4, 7))
z = max(8, 5)
print(z)

def add_numbers(x, y):
    total = x + y
    return total
    print(""This won't be printed"")

print(add_numbers(4, 5))",30
,Comments,Comments,"Comments are annotations to code used to make it easier to understand. They don't affect how code is run.
In Python, a comment is created by inserting an octothorpe (otherwise known as a number sign or hash symbol: #). All text after it on that line is ignored.
# this is a comment
Python doesn't have general purpose multiline comments, as do programming languages such as C.

Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific and have a different syntax. They are created by putting a multiline string containing an explanation of the function below the function's first line.
    """"""
    Print a word with an
    exclamation mark following it.
    """"""
Unlike conventional comments, docstrings are retained throughout the runtime of the program. This allows the programmer to inspect these comments at run time."," # """"""",31
,Functions as Objects,Functions as Objects,"Comments are annotations to code used to make it easier to understand. They don't affect how code is run.
In Python, a comment is created by inserting an octothorpe (otherwise known as a number sign or hash symbol: #). All text after it on that line is ignored.
Although they are created differently from normal variables, functions are just like any other kind of value.
They can be assigned and reassigned to variables, and later referenced by those names.
def multiply(x, y):
    return x * y

a = 4
b = 7
operation = multiply
print(operation(a, b))

The example above assigned the function multiply to a variable operation. Now, the name operation can also be used to call the function.

Functions can also be used as arguments of other functions.
def add(x, y):
    return x + y

def do_twice(func, x, y):
    return func(func(x, y), func(x, y))

a = 5
b = 10

print(do_twice(add, a, b))

As you can see, the function do_twice takes a function as its argument and calls it in its body.","def multiply(x, y):
    return x * y

a = 4
b = 7
operation = multiply
print(operation(a, b))

def add(x, y):
    return x + y

def do_twice(func, x, y):
    return func(func(x, y), func(x, y))

a = 5
b = 10

print(do_twice(add, a, b))",33
,Modules,Modules,"Modules are pieces of code that other people have written to fulfill common tasks, such as generating random numbers, performing mathematical operations, etc.

The basic way to use a module is to add import module_name at the top of your code, and then using module_name.var to access functions and values with the name var in the module.
For example, the following example uses the random module to generate random numbers:

import random

for i in range(5):
    value = random.randint(1, 6)
    print(value)

The code uses the randint function defined in the random module to print 5 random numbers in the range 1 to 6.

There is another kind of import that can be used if you only need certain functions from a module.
These take the form from module_name import var, and then var can be used as if it were defined normally in your code.
For example, to import only the pi constant from the math module:

from math import pi

print(pi)

Use a comma separated list to import multiple objects. For example:
from math import pi, sqrt

* imports all objects from a module. For example: from math import *
This is generally discouraged, as it confuses variables in your code with variables in the external module.

Trying to import a module that isn't available causes an ImportError.

You can import a module or object under a different name using the as keyword. This is mainly used when a module or object has a long or confusing name.
from math import sqrt as square_root
print(square_root(100))","import random

for i in range(5):
    value = random.randint(1, 6)
    print(value)

from math import pi
print(pi)

from math import sqrt as square_root
print(square_root(100))",33
,The Standard Library & pip,The Standard Library & pip,"There are three main types of modules in Python, those you write yourself, those you install from external sources, and those that are preinstalled with Python.
The last type is called the standard library, and contains many useful modules. Some of the standard library's useful modules include string, re, datetime, math, random, os, multiprocessing, subprocess, socket, email, json, doctest, unittest, pdb, argparse and sys.

Tasks that can be done by the standard library include string parsing, data serialization, testing, debugging and manipulating dates, emails, command line arguments, and much more!

Python's extensive standard library is one of its main strengths as a language.

The Standard Library
Some of the modules in the standard library are written in Python, and some are written in C.
Most are available on all platforms, but some are Windows or Unix specific.

We won't cover all of the modules in the standard library; there are simply too many. The complete documentation for the standard library is available online at www.python.org.

Modules
Many third-party Python modules are stored on the Python Package Index (PyPI).
The best way to install these is using a program called pip. This comes installed by default with modern distributions of Python. If you don't have it, it is easy to install online. Once you have it, installing libraries from PyPI is easy. Look up the name of the library you want to install, go to the command line (for Windows it will be the Command Prompt), and enter pip install library_name. Once you've done this, import the library and use it in your code.

Using pip is the standard way of installing libraries on most operating systems, but some libraries have prebuilt binaries for Windows. These are normal executable files that let you install libraries with a GUI the same way you would install other programs.

It's important to enter pip commands at the command line, not the Python interpreter.",,34
,Exceptions,Exceptions,"You have already seen exceptions in previous code. They occur when something goes wrong, due to incorrect code or input. When an exception occurs, the program immediately stops.
The following code produces the ZeroDivisionError exception by trying to divide 7 by 0.

num1 = 7
num2 = 0
print(num1/num2)

Different exceptions are raised for different reasons.
Common exceptions:
ImportError: an import fails;
IndexError: a list is indexed with an out-of-range number;
NameError: an unknown variable is used;
SyntaxError: the code can't be parsed properly;
TypeError: a function is called on a value of an inappropriate type;
ValueError: a function is called on a value of the correct type, but with an inappropriate value.

Python has several other built-in exceptions, such as ZeroDivisionError and OSError. Third-party libraries also often define their own exceptions.",,35
,Exception Handling,Exception Handling,"To handle exceptions, and to call code when an exception occurs, you can use a try/except statement.
The try block contains code that might throw an exception. If that exception occurs, the code in the try block stops being executed, and the code in the except block is run. If no error occurs, the code in the except block doesn't run.

For example:
try:
    num1 = 7
    num2 = 0
    print (num1 / num2)
    print(""Done calculation"")
except ZeroDivisionError:
    print(""An error occurred"")
    print(""due to zero division"")

In the code above, the except statement defines the type of exception to handle (in our case, the ZeroDivisionError).

A try statement can have multiple different except blocks to handle different exceptions.
Multiple exceptions can also be put into a single except block using parentheses, to have the except block handle all of them.

try:
    variable = 10
    print(variable + ""hello"")
    print(variable / 2)
except ZeroDivisionError:
    print(""Divided by zero"")
except (ValueError, TypeError):
    print(""Error occurred"")

An except statement without any exception specified will catch all errors. These should be used sparingly, as they can catch unexpected errors and hide programming mistakes.

For example:
try:
    word = ""spam""
    print(word / 0)
except:
    print(""An error occurred"")

Exception handling is particularly useful when dealing with user input.","try:
    num1 = 7
    num2 = 0
    print (num1 / num2)
    print(""Done calculation"")
except ZeroDivisionError:
    print(""An error occurred"")
    print(""due to zero division"")

try:
    variable = 10
    print(variable + ""hello"")
    print(variable / 2)
except ZeroDivisionError:
    print(""Divided by zero"")
except (ValueError, TypeError):
    print(""Error occurred"")

try:
    word = ""spam""
    print(word / 0)
except:
    print(""An error occurred"")",36
,finally,finally,"To ensure some code runs no matter what errors occur, you can use a finally statement. The finally statement is placed at the bottom of a try/except statement. Code within a finally statement always runs after execution of the code in the try, and possibly in the except, blocks.

try:
    print(""Hello"")
    print(1 / 0)
except ZeroDivisionError:
    print(""Divided by zero"")
finally:
    print(""This code will run no matter what"")

Code in a finally statement even runs if an uncaught exception occurs in one of the preceding blocks.

try:
    print(1)
    print(10 / 0)
except ZeroDivisionError:
    print(unknown_var)
finally:
    print(""This is executed last"")","try:
    print(""Hello"")
    print(1 / 0)
except ZeroDivisionError:
    print(""Divided by zero"")
finally:
    print(""This code will run no matter what"")

try:
    print(1)
    print(10 / 0)
except ZeroDivisionError:
    print(unknown_var)
finally:
    print(""This is executed last"")",37
,Raising Exceptions,Raising Exceptions,"You can raise exceptions by using the raise statement.
print(1)
raise ValueError
print(2)

You need to specify the type of the exception raised.

Exceptions can be raised with arguments that give detail about them.

For example:
name = ""123""
raise NameError(""Invalid name!"")

In except blocks, the raise statement can be used without arguments to re-raise whatever exception occurred.

For example:
try:
    num = 5 / 0
except:
    print(""An error occurred"")
    raise","print(1)
raise ValueError
print(2)

name = ""123""
raise NameError(""Invalid name!"")

try:
    num = 5 / 0
except:
    print(""An error occurred"")
    raise",38
,Assertions,Assertions,"An assertion is a sanity-check that you can turn on or turn off when you have finished testing the program.
An expression is tested, and if the result comes up false, an exception is raised.
Assertions are carried out through use of the assert statement.

print(1)
assert 2 + 2 == 4
print(2)
assert 1 + 1 == 3
print(3)

Programmers often place assertions at the start of a function to check for valid input, and after a function call to check for valid output.

The assert can take a second argument that is passed to the AssertionError raised if the assertion fails.
temp = -10
assert (temp >= 0), ""Colder than absolute zero!""

AssertionError exceptions can be caught and handled like any other exception using the try-except statement, but if not handled, this type of exception will terminate the program.","print(1)
assert 2 + 2 == 4
print(2)
assert 1 + 1 == 3
print(3)

temp = -10
assert (temp >= 0), ""Colder than absolute zero!""",39
,Opening Files,Opening Files,"You can use Python to read and write the contents of files.
Text files are the easiest to manipulate. Before a file can be edited, it must be opened, using the open function.

myfile = open(""filename.txt"")

The argument of the open function is the path to the file. If the file is in the current working directory of the program, you can specify only its name.

You can specify the mode used to open a file by applying a second argument to the open function.
Sending ""r"" means open in read mode, which is the default.
Sending ""w"" means write mode, for rewriting the contents of a file.
Sending ""a"" means append mode, for adding new content to the end of the file.

Adding ""b"" to a mode opens it in binary mode, which is used for non-text files (such as image and sound files).

For example:
# write mode
open(""filename.txt"", ""w"")

# read mode
open(""filename.txt"", ""r"")
open(""filename.txt"")

# binary write mode
open(""filename.txt"", ""wb"")

You can use the + sign with each of the modes above to give them extra access to files. For example, r+ opens the file for both reading and writing.

Once a file has been opened and used, you should close it.
This is done with the close method of the file object.

file = open(""filename.txt"", ""w"")
# do stuff to the file
file.close()",,40
,Reading Files,Reading Files,"The contents of a file that has been opened in text mode can be read using the read method.

file = open(""filename.txt"", ""r"")
cont = file.read()
print(cont)
file.close()

This will print all of the contents of the file ""filename.txt"".

To read only a certain amount of a file, you can provide a number as an argument to the read function. This determines the number of bytes that should be read.
You can make more calls to read on the same file object to read more of the file byte by byte. With no argument, read returns the rest of the file.

file = open(""filename.txt"", ""r"")
print(file.read(16))
print(file.read(4))
print(file.read(4))
print(file.read())
file.close()

Just like passing no arguments, negative values will return the entire contents.

After all contents in a file have been read, any attempts to read further from that file will return an empty string, because you are trying to read from the end of the file.

file = open(""filename.txt"", ""r"")
file.read()
print(""Re-reading"")
print(file.read())
print(""Finished"")
file.close()

Result:
>>>
Re-reading
Finished
>>>
Just like passing no arguments, negative values will return the entire contents.

To retrieve each line in a file, you can use the readlines method to return a list in which each element is a line in the file.

For example:
file = open(""filename.txt"", ""r"")
print(file.readlines())
file.close()

Result:
>>>
['Line 1 text \n', 'Line 2 text \n', 'Line 3 text']
>>>
You can also use a for loop to iterate through the lines in the file:

file = open(""filename.txt"", ""r"")

for line in file:
    print(line)

file.close()

Result:
>>>
Line 1 text
Line 2 text
Line 3 text
>>>
In the output, the lines are separated by blank lines, as the print function automatically adds a new line at the end of its output.",,41
,Writing Files,Writing Files,"To write to files you use the write method, which writes a string to the file.

For example:
file = open(""newfile.txt"", ""w"")
file.write(""This has been written to a file"")
file.close()

file = open(""newfile.txt"", ""r"")
print(file.read())
file.close()

The ""w"" mode will create a file, if it does not already exist.

When a file is opened in write mode, the file's existing content is deleted.
file = open(""newfile.txt"", ""w"")
file.write(""Some new text"")
file.close()

file = open(""newfile.txt"", ""r"")
print(""Reading new contents"")
print(file.read())
print(""Finished"")
file.close()

The write method returns the number of bytes written to a file, if successful.

msg = ""Hello world!""
file = open(""newfile.txt"", ""w"")
amount_written = file.write(msg)
print(amount_written)
file.close()

To write something other than a string, it needs to be converted to a string first.",,42
,Working with Files,Working with Files,"It is good practice to avoid wasting resources by making sure that files are always closed after they have been used. One way of doing this is to use try and finally.

try:
   f = open(""filename.txt"")
   print(f.read())
finally:
   f.close()

This ensures that the file is always closed, even if an error occurs.

An alternative way of doing this is using with statements. This creates a temporary variable (often called f), which is only accessible in the indented block of the with statement.

with open(""filename.txt"") as f:
   print(f.read())

The file is automatically closed at the end of the with statement, even if exceptions occur within it.","try:
   f = open(""filename.txt"")
   print(f.read())
finally:
   f.close()

with open(""filename.txt"") as f:
   print(f.read())",43
,None,None,"The None object is used to represent the absence of a value.
It is similar to null in other programming languages.
Like other ""empty"" values, such as 0, [] and the empty string, it is False when converted to a Boolean variable.
When entered at the Python console, it is displayed as the empty string.

print(None)

The None object is returned by any function that doesn't explicitly return anything else.

def some_func():
    print(""Hi!"")

var = some_func()
print(var)","print(None)

def some_func():
    print(""Hi!"")

var = some_func()
print(var)",44
,Dictionaries,Dictionaries,"Dictionaries are data structures used to map arbitrary keys to values.
Lists can be thought of as dictionaries with integer keys within a certain range.
Dictionaries can be indexed in the same way as lists, using square brackets containing keys.

Example:
ages = {""Dave"": 24, ""Mary"": 42, ""John"": 58}
print(ages[""Dave""])
print(ages[""Mary""])

Each element in a dictionary is represented by a key:value pair.

Trying to index a key that isn't part of the dictionary returns a KeyError.

Example:
primary = {
    ""red"": [255, 0, 0], 
    ""green"": [0, 255, 0], 
    ""blue"": [0, 0, 255], 
}

print(primary[""red""])
print(primary[""yellow""])

As you can see, a dictionary can store any types of data as values.

An empty dictionary is defined as {}.

Only immutable objects can be used as keys to dictionaries. Immutable objects are those that can't be changed. So far, the only mutable objects you've come across are lists and dictionaries. Trying to use a mutable object as a dictionary key causes a TypeError.

bad_dict = {
    [1, 2, 3]: ""one two three"", 
}","ages = {""Dave"": 24, ""Mary"": 42, ""John"": 58}
print(ages[""Dave""])
print(ages[""Mary""])

primary = {
    ""red"": [255, 0, 0], 
    ""green"": [0, 255, 0], 
    ""blue"": [0, 0, 255], 
}

print(primary[""red""])
print(primary[""yellow""])",45
,Dictionary functions,Dictionary functions,"Just like lists, dictionary keys can be assigned to different values.
However, unlike lists, a new dictionary key can also be assigned a value, not just ones that already exist.
squares = {1: 1, 2: 4, 3: ""error"", 4: 16,}
squares[8] = 64
squares[3] = 9
print(squares)

To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list.

Example:
nums = {
    1: ""one"",
    2: ""two"",
    3: ""three"",
}
print(1 in nums)
print(""three"" in nums)
print(4 not in nums)

A useful dictionary method is get. It does the same thing as indexing, but if the key is not found in the dictionary it returns another specified value instead ('None', by default).

Example:
pairs = {1: ""apple"",
    ""orange"": [2, 3, 4], 
    True: False, 
    None: ""True"",
}

print(pairs.get(""orange""))
print(pairs.get(7))
print(pairs.get(12345, ""not in dictionary""))","squares = {1: 1, 2: 4, 3: ""error"", 4: 16,}
squares[8] = 64
squares[3] = 9
print(squares)

nums = {
    1: ""one"",
    2: ""two"",
    3: ""three"",
}
print(1 in nums)
print(""three"" in nums)
print(4 not in nums)

pairs = {1: ""apple"",
    ""orange"": [2, 3, 4], 
    True: False, 
    None: ""True"",
}

print(pairs.get(""orange""))
print(pairs.get(7))
print(pairs.get(12345, ""not in dictionary""))",46
,Tuples,Tuples,"Tuples are very similar to lists, except that they are immutable (they cannot be changed).
Also, they are created using parentheses, rather than square brackets.

Example:
words = (""spam"", ""eggs"", ""sausages"",)
PY
You can access the values in the tuple with their index, just as you did with lists:
words = (""spam"", ""eggs"", ""sausages"",)
print(words[0])

Tuples can be created without the parentheses, by just separating the values with commas.

Example:
my_tuple = ""one"", ""two"", ""three""
print(my_tuple[0])

An empty tuple is created using an empty parenthesis pair.

tpl = ()
Tuples are faster than lists, but they cannot be changed.","words = (""spam"", ""eggs"", ""sausages"",)

words = (""spam"", ""eggs"", ""sausages"",)
print(words[0])

my_tuple = ""one"", ""two"", ""three""
print(my_tuple[0])

tpl = ()",47
,List Slices,List Slices,"List slices provide a more advanced way of retrieving values from a list. Basic list slicing involves indexing a list with two colon-separated integers. This returns a new list containing all the values in the old list between the indices.

Example:
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[2:6])
print(squares[3:8])
print(squares[0:1])

Like the arguments to range, the first index provided in a slice is included in the result, but the second isn't.

If the first number in a slice is omitted, it is taken to be the start of the list.
If the second number is omitted, it is taken to be the end.

Example:
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[:7])
print(squares[7:])

Slicing can also be done on tuples.

List slices can also have a third number, representing the step, to include only alternate values in the slice.
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[::2])
print(squares[2:8:3])

[2:8:3] will include elements starting from the 2nd index up to the 8th with a step of 3.

Negative values can be used in list slicing (and normal list indexing). When negative values are used for the first and second values in a slice (or a normal index), they count from the end of the list.
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[1:-1])

If a negative value is used for the step, the slice is done backwards.
Using [::-1] as a slice is a common and idiomatic way to reverse a list.","squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[2:6])
print(squares[3:8])
print(squares[0:1])

squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[:7])
print(squares[7:])

squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[::2])
print(squares[2:8:3])

[2:8:3] will include elements starting from the 2nd index up to the 8th with a step of 3.

squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(squares[1:-1])

Using [::-1] as a slice is a common and idiomatic way to reverse a list.",48
,List Comprehensions,List Comprehensions,"List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule.
For example, we can do the following:
# a list comprehension
cubes = [i**3 for i in range(5)]
print(cubes)

List comprehensions are inspired by set-builder notation in mathematics.

A list comprehension can also contain an if statement to enforce a condition on values in the list.

Example:
evens=[i**2 for i in range(10) if i**2 % 2 == 0]
print(evens)

Trying to create a list in a very extensive range will result in a MemoryError.
This code shows an example where the list comprehension runs out of memory.

even = [2*i for i in range(10**100)]","cubes = [i**3 for i in range(5)]
print(cubes)

evens=[i**2 for i in range(10) if i**2 % 2 == 0]
print(evens)

even = [2*i for i in range(10**100)]",49
,String Formatting,String Formatting,"So far, to combine strings and non-strings, you've converted the non-strings to strings and added them.
String formatting provides a more powerful way to embed non-strings within strings. String formatting uses a string's format method to substitute a number of arguments in the string.

Example:
nums = [4, 5, 6]
msg = ""Numbers: {0} {1} {2}"". format(nums[0], nums[1], nums[2])
print(msg)

Each argument of the format function is placed in the string at the corresponding position, which is determined using the curly braces { }.

String formatting can also be done with named arguments.

Example:
a = ""{x}, {y}"".format(x=5, y=12)
print(a)","nums = [4, 5, 6]
msg = ""Numbers: {0} {1} {2}"". format(nums[0], nums[1], nums[2])
print(msg)

a = ""{x}, {y}"".format(x=5, y=12)
print(a)",50
,String Functions,String Functions,"Python contains many useful built-in functions and methods to accomplish common tasks.
join - joins a list of strings with another string as a separator.
replace - replaces one substring in a string with another.
startswith and endswith - determine if there is a substring at the start and end of a string, respectively.
To change the case of a string, you can use lower and upper.
The method split is the opposite of join, turning a string with a certain separator into a list.

Some examples:","print("", "".join([""spam"", ""eggs"", ""ham""]))
#prints ""spam, eggs, ham""

print(""Hello ME"".replace(""ME"", ""world""))
#prints ""Hello world""

print(""This is a sentence."".startswith(""This""))
# prints ""True""

print(""This is a sentence."".endswith(""sentence.""))
# prints ""True""

print(""This is a sentence."".upper())
# prints ""THIS IS A SENTENCE.""

print(""AN ALL CAPS SENTENCE"".lower())
#prints ""an all caps sentence""

print(""spam, eggs, ham"".split("", ""))
#prints ""['spam', 'eggs', 'ham']""",51
,Numeric Functions,Numeric Functions,"To find the maximum or minimum of some numbers or a list, you can use max or min.
To find the distance of a number from zero (its absolute value), use abs.
To round a number to a certain number of decimal places, use round.
To find the total of a list, use sum.
Some examples:","print(min(1, 2, 3, 4, 0, 2, 1))
print(max([1, 4, 9, 2, 5, 6, 8]))
print(abs(-99))
print(abs(42))
print(sum([1, 2, 3, 4, 5]))",52
,List Functions,List Functions,"Often used in conditional statements, all and any take a list as an argument, and return True if all or any (respectively) of their arguments evaluate to True (and False otherwise).
The function enumerate can be used to iterate through the values and indices of a list simultaneously.

Example:","nums = [55, 44, 33, 22, 11]

if all([i > 5 for i in nums]):
    print(""All larger than 5"")

if any([i % 2 == 0 for i in nums]):
    print(""At least one is even"")

for v in enumerate(nums):
    print(v)",53
,Functional Programming,Functional Programming,"Functional programming is a style of programming that (as the name suggests) is based around functions.
A key part of functional programming is higher-order functions. We have seen this idea briefly in the previous lesson on functions as objects. Higher-order functions take other functions as arguments, or return them as results.

Example:","def apply_twice(func, arg):
    return func(func(arg))

def add_five(x):
    return x + 5

print(apply_twice(add_five, 10))

The function apply_twice takes another function as its argument, and calls it twice inside its body.",54
,Pure Functions,Pure Functions,"Functional programming seeks to use pure functions. Pure functions have no side effects, and return a value that depends only on their arguments.
This is how functions in math work: for example, The cos(x) will, for the same value of x, always return the same result.
Below are examples of pure and impure functions.

Pure function:
def pure_function(x, y):
  temp = x + 2*y
  return temp / (2*x + y)

Impure function:
some_list = []

def impure(arg):
  some_list.append(arg)

The function above is not pure, because it changed the state of some_list.

Using pure functions has both advantages and disadvantages.
Pure functions are:
- easier to reason about and test.
- more efficient. Once the function has been evaluated for an input, the result can be stored and referred to the next time the function of that input is needed, reducing the number of times the function is called. This is called memoization.
- easier to run in parallel.

The main disadvantage of using only pure functions is that they majorly complicate the otherwise simple task of I/O, since this appears to inherently require side effects.
They can also be more difficult to write in some situations.","Pure function:
def pure_function(x, y):
  temp = x + 2*y
  return temp / (2*x + y)

Impure function:
some_list = []

def impure(arg):
  some_list.append(arg)",55
,Lambdas,Lambdas,"Creating a function normally (using def) assigns it to a variable automatically.
This is different from the creation of other objects - such as strings and integers - which can be created on the fly, without assigning them to a variable.
The same is possible with functions, provided that they are created using lambda syntax. Functions created this way are known as anonymous.
This approach is most commonly used when passing a simple function as an argument to another function. The syntax is shown in the next example and consists of the lambda keyword followed by a list of arguments, a colon, and the expression to evaluate and return.

def my_func(f, arg):
  return f(arg)

my_func(lambda x: 2*x*x, 5)

Lambda functions get their name from lambda calculus, which is a model of computation invented by Alonzo Church.

Lambda functions aren't as powerful as named functions.
They can only do things that require a single expression - usually equivalent to a single line of code.

Example:
#named function
def polynomial(x):
    return x**2 + 5*x + 4
print(polynomial(-4))

#lambda
print((lambda x: x**2 + 5*x + 4) (-4))

In the code above, we created an anonymous function on the fly and called it with an argument.

Lambda functions can be assigned to variables, and used like normal functions.

Example:
double = lambda x: x * 2
print(double(7))

However, there is rarely a good reason to do this - it is usually better to define a function with def instead.","def my_func(f, arg):
  return f(arg)

my_func(lambda x: 2*x*x, 5)

#named function
def polynomial(x):
    return x**2 + 5*x + 4
print(polynomial(-4))

#lambda
print((lambda x: x**2 + 5*x + 4) (-4))

double = lambda x: x * 2
print(double(7))",56
,map,map,"The built-in functions map and filter are very useful higher-order functions that operate on lists (or similar objects called iterables).
The function map takes a function and an iterable as arguments, and returns a new iterable with the function applied to each argument.

Example:
def add_five(x):
    return x + 5

nums = [11, 22, 33, 44, 55]
result = list(map(add_five, nums))
print(result)

We could have achieved the same result more easily by using lambda syntax.

nums = [11, 22, 33, 44, 55]

result = list(map(lambda x: x+5, nums))
print(result)

To convert the result into a list, we used list explicitly.","def add_five(x):
    return x + 5

nums = [11, 22, 33, 44, 55]
result = list(map(add_five, nums))
print(result)

nums = [11, 22, 33, 44, 55]

result = list(map(lambda x: x+5, nums))
print(result)",57
,filter,filter,"The function filter filters an iterable by removing items that don't match a predicate (a function that returns a Boolean).

Example:
nums = [11, 22, 33, 44, 55]
res = list(filter(lambda x: x%2==0, nums))
print(res)

Like map, the result has to be explicitly converted to a list if you want to print it.","nums = [11, 22, 33, 44, 55]
res = list(filter(lambda x: x%2==0, nums))
print(res)",58
,Generators,Generators,"Generators are a type of iterable, like lists or tuples.
Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated through with for loops.
They can be created using functions and the yield statement.

Example:
def countdown():
    i=5
    while i > 0:
        yield i
        i -= 1

for i in countdown():
    print(i)

The yield statement is used to define a generator, replacing the return of a function to provide a result to its caller without destroying local variables.

Due to the fact that they yield one item at a time, generators don't have the memory restrictions of lists.
In fact, they can be infinite!
In short, generators allow you to declare a function that behaves like an iterator, i.e. it can be used in a for loop.

def infinite_sevens():
  while True:
    yield 7
        
for i in infinite_sevens():
  print(i)

>>>
7
7
7
7
7
7
7
...

Finite generators can be converted into lists by passing them as arguments to the list function.
def numbers(x):
    for i in range(x):
        if i % 2 == 0:
            yield i

print(list(numbers(11)))

Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all the elements have been generated before we start to use them.","def countdown():
    i=5
    while i > 0:
        yield i
        i -= 1

for i in countdown():
    print(i)

def infinite_sevens():
  while True:
    yield 7
        
for i in infinite_sevens():
  print(i)

>>>
7
7
7
7
7
7
7
...

def numbers(x):
    for i in range(x):
        if i % 2 == 0:
            yield i

print(list(numbers(11)))",59
,Decorators,Decorators,"Decorators provide a way to modify functions using other functions.
This is ideal when you need to extend the functionality of functions that you don't want to modify.

Example:
def decor(func):
  def wrap():
    print(""============"")
    func()
    print(""============"")
  return wrap

def print_text():
  print(""Hello world!"")

decorated = decor(print_text)
decorated()

We defined a function named decor that has a single parameter func. Inside decor, we defined a nested function named wrap. The wrap function will print a string, then call func(), and print another string. The decor function returns the wrap function as its result.
We could say that the variable decorated is a decorated version of print_text - it's print_text plus something.
In fact, if we wrote a useful decorator we might want to replace print_text with the decorated version altogether so we always got our ""plus something"" version of print_text.
This is done by re-assigning the variable that contains our function:

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")

print_text = decor(print_text)
print_text()

Now print_text corresponds to our decorated version.

In our previous example, we decorated our function by replacing the variable containing the function with a wrapped version.

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")

print_text = decor(print_text)

print_text();

This pattern can be used at any time, to wrap any function.
Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name and the @ symbol.
If we are defining a function we can ""decorate"" it with the @ symbol like:

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")

print_text = decor(print_text)

print_text();

A single function can have multiple decorators.","def decor(func):
  def wrap():
    print(""============"")
    func()
    print(""============"")
  return wrap

def print_text():
  print(""Hello world!"")

decorated = decor(print_text)
decorated()

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")

print_text = decor(print_text)
print_text()

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")
print_text = decor(print_text)
print_text();

def decor(func):
    def wrap():
        print(""============"")
        func()
        print(""============"")
    return wrap

def print_text():
    print(""Hello world!"")
print_text = decor(print_text)
print_text();",60
,Recursion,Recursion,"Recursion is a very important concept in functional programming.
The fundamental part of recursion is self-reference - functions calling themselves. It is used to solve problems that can be broken up into easier sub-problems of the same type.

A classic example of a function that is implemented recursively is the factorial function, which finds the product of all positive integers below a specified number.
For example, 5! (5 factorial) is 5 * 4 * 3 * 2 * 1 (120). To implement this recursively, notice that 5! = 5 * 4!, 4! = 4 * 3!, 3! = 3 * 2!, and so on. Generally, n! = n * (n-1)!.
Furthermore, 1! = 1. This is known as the base case, as it can be calculated without performing any more factorials.
Below is a recursive implementation of the factorial function.

def factorial(x):
    if x == 1:
        return 1
    else: 
        return x * factorial(x-1)

print(factorial(5))

The base case acts as the exit condition of the recursion.

Recursive functions can be infinite, just like infinite while loops. These often occur when you forget to implement the base case.
Below is an incorrect version of the factorial function. It has no base case, so it runs until the interpreter runs out of memory and crashes.

def factorial(x):
    return x * factorial(x-1)

print(factorial(5))

Recursion can also be indirect. One function can call a second, which calls the first, which calls the second, and so on. This can occur with any number of functions.

Example:
def is_even(x):
    if x == 0:
        return True
    else:
        return is_odd(x-1)

def is_odd(x):
    return not is_even(x)


print(is_odd(17))
print(is_even(23))","def factorial(x):
    if x == 1:
        return 1
    else: 
        return x * factorial(x-1)

print(factorial(5))

def factorial(x):
    return x * factorial(x-1)

print(factorial(5))

def is_even(x):
    if x == 0:
        return True
    else:
        return is_odd(x-1)

def is_odd(x):
    return not is_even(x)

print(is_odd(17))
print(is_even(23))",61
,Sets,Sets,"Sets are data structures, similar to lists or dictionaries. They are created using curly braces, or the set function. They share some functionality with lists, such as the use of in to check whether they contain a particular item.

num_set = {1, 2, 3, 4, 5}
word_set = set([""spam"", ""eggs"", ""sausage""])

print(3 in num_set)
print(""spam"" not in word_set)

To create an empty set, you must use set(), as {} creates an empty dictionary.

Sets differ from lists in several ways, but share several list operations such as len.
They are unordered, which means that they can't be indexed.
They cannot contain duplicate elements.
Due to the way they're stored, it's faster to check whether an item is part of a set, rather than part of a list.
Instead of using append to add to a set, use add.
The method remove removes a specific element from a set; pop removes an arbitrary element.

nums = {1, 2, 1, 3, 1, 4, 5, 6}
print(nums)
nums.add(-7)
nums.remove(3)
print(nums)

Basic uses of sets include membership testing and the elimination of duplicate entries.

Sets can be combined using mathematical operations.
The union operator | combines two sets to form a new one containing items in either.
The intersection operator & gets items only in both.
The difference operator - gets items in the first set but not in the second.
The symmetric difference operator ^ gets items in either set, but not both.

first = {1, 2, 3, 4, 5, 6}
second = {4, 5, 6, 7, 8, 9}

print(first | second)
print(first & second)
print(first - second)
print(second - first)
print(first ^ second)","num_set = {1, 2, 3, 4, 5}
word_set = set([""spam"", ""eggs"", ""sausage""])

print(3 in num_set)
print(""spam"" not in word_set)

nums = {1, 2, 1, 3, 1, 4, 5, 6}
print(nums)
nums.add(-7)
nums.remove(3)
print(nums)

first = {1, 2, 3, 4, 5, 6}
second = {4, 5, 6, 7, 8, 9}

print(first | second)
print(first & second)
print(first - second)
print(second - first)
print(first ^ second)",62
,Data Structures,Data Structures,"As we have seen in the previous lessons, Python supports the following data structures: lists, dictionaries, tuples, sets.

When to use a dictionary:
- When you need a logical association between a key:value pair.
- When you need fast lookup for your data, based on a custom key.
- When your data is being constantly modified. Remember, dictionaries are mutable.

When to use the other types:
- Use lists if you have a collection of data that does not need random access. Try to choose lists when you need a simple, iterable collection that is modified frequently.
- Use a set if you need uniqueness for the elements.
- Use tuples when your data cannot change.

Many times, a tuple is used in combination with a dictionary, for example, a tuple might represent a key, because it's immutable.",,63
,itertools,itertools,"The module itertools is a standard library that contains several functions that are useful in functional programming.
One type of function it produces is infinite iterators.
The function count counts up infinitely from a value.
The function cycle infinitely iterates through an iterable (for instance a list or string).
The function repeat repeats an object, either infinitely or a specific number of times.

Example:
from itertools import count

for i in count(3):
    print(i)
    if i >=11:
        break

There are many functions in itertools that operate on iterables, in a similar way to map and filter.
Some examples:
takewhile - takes items from an iterable while a predicate function remains true;
chain - combines several iterables into one long one;
accumulate - returns a running total of values in an iterable.

from itertools import accumulate, takewhile

nums = list(accumulate(range(8)))
print(nums)
print(list(takewhile(lambda x: x<= 6, nums)))

There are also several combinatoric functions in itertool, such as product and permutation.
These are used when you want to accomplish a task with all possible combinations of some items.

Example:
from itertools import product, permutations

letters = (""A"", ""B"")
print(list(product(letters, range(2))))
print(list(permutations(letters))) ","from itertools import count

for i in count(3):
    print(i)
    if i >=11:
        break

from itertools import accumulate, takewhile

nums = list(accumulate(range(8)))
print(nums)
print(list(takewhile(lambda x: x<= 6, nums)))

from itertools import product, permutations

letters = (""A"", ""B"")
print(list(product(letters, range(2))))
print(list(permutations(letters))) ",64
,Fibonacci,Fibonacci,"The Fibonacci sequence is one of the most famous formulas in mathematics.
Each number in the sequence is the sum of the two numbers that precede it.
For example, here is the Fibonacci sequence for 10 numbers, starting from 0: 0,1,1,2,3,5,8,13,21,34.

Write a program to take N (variable num in code template) positive numbers as input, and recursively calculate and output the first N numbers of the Fibonacci sequence (starting from 0).

Sample Input
6

Sample Output
0
1
1
2
3
5

If you are making the Fibonacci sequence for n numbers, you should use n<=1 condition as the base case.","num = int(input())

def fibonacci(n):
    if n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        seq = fibonacci(n - 1)
        seq.append(seq[-1] + seq[-2])
        return seq

if num > 0:
    result = fibonacci(num)
    for i in result:  # Iterate directly over the values in the result
        print(i)  # Print each value in the Fibonacci sequence
else:
    print(""Input must be a positive integer."")",65
,Fibonacci,Fibonacci,"The Fibonacci sequence is one of the most famous formulas in mathematics.
Each number in the sequence is the sum of the two numbers that precede it.
For example, here is the Fibonacci sequence for 10 numbers, starting from 0: 0,1,1,2,3,5,8,13,21,34.

Write a program to take N (variable num in code template) positive numbers as input, and recursively calculate and output the first N numbers of the Fibonacci sequence (starting from 0).

Sample Input
6

Sample Output
0
1
1
2
3
5

If you are making the Fibonacci sequence for n numbers, you should use n<=1 condition as the base case.","num = int(input())

def fibonacci(n):
    if n<=1:
        return n
    else:
       return fibonacci(n-1)+fibonacci(n-2)
               
for a in range(num):
    print(fibonacci(a))",66
,Classes,Classes,"We have previously looked at two paradigms of programming - imperative (using statements, loops, and functions as subroutines), and functional (using pure functions, higher-order functions, and recursion).

Another very popular paradigm is object-oriented programming (OOP).
Objects are created using classes, which are actually the focal point of OOP.
The class describes what the object will be, but is separate from the object itself. In other words, a class can be described as an object's blueprint, description, or definition.
You can use the same class as a blueprint for creating multiple different objects.

Classes are created using the keyword class and an indented block, which contains class methods (which are functions).
Below is an example of a simple class and its objects.

class Cat:
  def __init__(self, color, legs):
    self.color = color
    self.legs = legs

felix = Cat(""ginger"", 4)
rover = Cat(""dog-colored"", 4)
stumpy = Cat(""brown"", 3)

This code defines a class named Cat, which has two attributes: color and legs.
Then the class is used to create 3 separate objects of that class.
Tap Continue to learn more!","class Cat:
  def __init__(self, color, legs):
    self.color = color
    self.legs = legs

felix = Cat(""ginger"", 4)
rover = Cat(""dog-colored"", 4)
stumpy = Cat(""brown"", 3)",67
,__init__,__init__,"The __init__ method is the most important method in a class.
This is called when an instance (object) of the class is created, using the class name as a function.

All methods must have self as their first parameter, although it isn't explicitly passed, Python adds the self argument to the list for you; you do not need to include it when you call the methods. Within a method definition, self refers to the instance calling the method.

Instances of a class have attributes, which are pieces of data associated with them.
In this example, Cat instances have attributes color and legs. These can be accessed by putting a dot, and the attribute name after an instance.
In an __init__ method, self.attribute can therefore be used to set the initial value of an instance's attributes.

Example:
class Cat:
    def __init__(self, color, legs):
        self.color = color
        self.legs = legs

felix = Cat(""ginger"", 4)
print(felix.color)

In the example above, the __init__ method takes two arguments and assigns them to the object's attributes. The __init__ method is called the class constructor.

class Student:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        print(self.name+"" says hi"")

obj = Student(""John"")
obj.greet()","class Cat:
    def __init__(self, color, legs):
        self.color = color
        self.legs = legs

felix = Cat(""ginger"", 4)
print(felix.color)

class Student:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        print(self.name+"" says hi"")

obj = Student(""John"")
obj.greet()",68
,Methods,Methods,"Classes can have other methods defined to add functionality to them.
Remember, that all methods must have self as their first parameter.
These methods are accessed using the same dot syntax as attributes.

Example:
class Dog:
  def __init__(self, name, color):
    self.name = name
    self.color = color

  def bark(self):
    print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.name)
fido.bark()

Classes can also have class attributes, created by assigning variables within the body of the class. These can be accessed either from instances of the class, or the class itself.

Example:
class Dog:
    legs = 4
    def __init__(self, name, color):
        self.name = name
        self.color = color

fido = Dog(""Fido"", ""brown"")
print(fido.legs)
print(Dog.legs)

Class attributes are shared by all instances of the class.

Trying to access an attribute of an instance that isn't defined causes an AttributeError. This also applies when you call an undefined method.

Example:
class Rectangle: 
    def __init__(self, width, height):
        self.width = width
        self.height = height

rect = Rectangle(7, 8)
print(rect.color)
OUTPUT: Traceback (most recent call last):
  File ""./Playground/file0.py"", line 7, in <module>
    print(rect.color)
AttributeError: 'Rectangle' object has no attribute 'color'","class Dog:
  def __init__(self, name, color):
    self.name = name
    self.color = color

  def bark(self):
    print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.name)
fido.bark()
-----------------
class Dog:
    legs = 4
    def __init__(self, name, color):
        self.name = name
        self.color = color

fido = Dog(""Fido"", ""brown"")
print(fido.legs)
print(Dog.legs)
-----------------
class Rectangle: 
    def __init__(self, width, height):
        self.width = width
        self.height = height

rect = Rectangle(7, 8)
print(rect.color)
OUTPUT: Traceback (most recent call last):
  File ""./Playground/file0.py"", line 7, in <module>
    print(rect.color)
AttributeError: 'Rectangle' object has no attribute 'color'",69
,Inheritance subclass,Inheritance subclass,"Inheritance provides a way to share functionality between classes.
Imagine several classes, Cat, Dog, Rabbit and so on. Although they may differ in some ways (only Dog might have the method bark), they are likely to be similar in others (all having the attributes color and name).
This similarity can be expressed by making them all inherit from a superclass Animal, which contains the shared functionality.
To inherit a class from another class, put the superclass name in parentheses after the class name.

Example:
class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.color)
fido.bark()
OUTPUT
brown
Woof!

class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Cat(""Fido"", ""white"")
print(fido.color)
fido.purr()
OUTPUT
white
Purr...

A class that inherits from another class is called a subclass.
A class that is inherited from is called a superclass.
If a class inherits from another with the same attributes or methods, it overrides them.

class Wolf: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def bark(self):
        print(""Grr..."")

class Dog(Wolf): # subclass of Wolf
    def bark(self):
        print(""Woof"")

husky = Dog(""Max"", ""grey"")
husky.bark()
OUTPUT
Woof

The reason the `husky.bark()` call prints `""Woof""` instead of `""Grr...""` is because the `Dog` class **overrides** the `bark` method from its parent class, `Wolf`.

### Key Concepts:
1. **Inheritance:**
   - The `Dog` class inherits from the `Wolf` class, so all methods and attributes of `Wolf` are available to `Dog` unless overridden.

2. **Method Overriding:**
   - When a subclass (like `Dog`) defines a method with the same name as a method in its parent class (`Wolf`), the subclass's method takes precedence. This is called **method overriding**.

3. **Instance Behavior:**
   - When `husky.bark()` is called, Python looks for the `bark` method in the `Dog` class first. Since the `Dog` class has its own `bark` method, it uses that instead of the one in `Wolf`.

### Why doesn't it use `Wolf.bark`?
The method lookup follows the **Method Resolution Order (MRO)**. Python checks methods in the following order:
1. The class of the instance (`Dog` in this case).
2. The parent class (`Wolf`).

Since `Dog` defines its own `bark` method, Python doesn't need to check `Wolf`.

If you want the `Dog` class to call the `bark` method from `Wolf`, you can explicitly invoke it using `super()`:

```python
class Dog(Wolf):
    def bark(self):
        super().bark()  # Calls the `bark` method from `Wolf`
        print(""Woof"")
```

Now, `husky.bark()` would print:
```
Grr...
Woof
```

### Summary:
- The `Dog` class overrides the `bark` method from `Wolf`, so `husky.bark()` calls the overridden version in `Dog`.
- The `bark` method is not ""inherited"" in the sense that it's replaced in the subclass.
- You can use `super()` to call the parent class's method explicitly.

class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.color)
fido.bark()
OUTPUT
brown
Woof!

class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Cat(""Fido"", ""white"")
print(fido.color)
fido.purr()
OUTPUT
white
Purr...
-------------------

class Wolf: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def bark(self):
        print(""Grr..."")

class Dog(Wolf): # subclass of Wolf
    def bark(self):
        print(""Woof"")

husky = Dog(""Max"", ""grey"")
husky.bark()
OUTPUT
Woof

The reason the `husky.bark()` call prints `""Woof""` instead of `""Grr...""` is because the `Dog` class **overrides** the `bark` method from its parent class, `Wolf`.

### Key Concepts:
1. **Inheritance:**
   - The `Dog` class inherits from the `Wolf` class, so all methods and attributes of `Wolf` are available to `Dog` unless overridden.

2. **Method Overriding:**
   - When a subclass (like `Dog`) defines a method with the same name as a method in its parent class (`Wolf`), the subclass's method takes precedence. This is called **method overriding**.

3. **Instance Behavior:**
   - When `husky.bark()` is called, Python looks for the `bark` method in the `Dog` class first. Since the `Dog` class has its own `bark` method, it uses that instead of the one in `Wolf`.

### Why doesn't it use `Wolf.bark`?
The method lookup follows the **Method Resolution Order (MRO)**. Python checks methods in the following order:
1. The class of the instance (`Dog` in this case).
2. The parent class (`Wolf`).

Since `Dog` defines its own `bark` method, Python doesn't need to check `Wolf`.

If you want the `Dog` class to call the `bark` method from `Wolf`, you can explicitly invoke it using `super()`:

```python
class Dog(Wolf):
    def bark(self):
        super().bark()  # Calls the `bark` method from `Wolf`
        print(""Woof"")
```

Now, `husky.bark()` would print:
```
Grr...
Woof
```

### Summary:
- The `Dog` class overrides the `bark` method from `Wolf`, so `husky.bark()` calls the overridden version in `Dog`.
- The `bark` method is not ""inherited"" in the sense that it's replaced in the subclass.
- You can use `super()` to call the parent class's method explicitly.

Excercise:
Complete the provided code to inherit the Car class from the Vehicle class, create a Car object and call its horn() method, which is inherited from the Vehicle superclass.

class Vehicle: 
    def horn(self):
        print(""Beep!"")

class Car(Vehicle):
    def __init__(self, name, color):
        self.name = name
        self.color = color

obj = Car(""BMW"", ""red"")
obj.horn()

----------------------------------
Inheritance can also be indirect. One class can inherit from another, and that class can inherit from a third class. However, circular inheritance is not possible.

class A:
    def method(self):
        print(""A method"")
    
class B(A):
    def another_method(self):
        print(""B method"")
    
class C(B):
    def third_method(self):
        print(""C method"")
    
c = C()
c.method()
c.another_method()
c.third_method()

OUTPUT
A method
B method
C method

-------------------------------------

class A:
def a(self):
print(1)
class B(A):
def a(self):
print(2)

class C(B):
def c(self):
print(3)

c = C()
c.a()

OUTPUT: 2
-------------------------------------
The function super is a useful inheritance-related function that refers to the parent class. It can be used to find the method with a certain name in an object's superclass.
super().spam() calls the spam method of the superclass.

class A:
    def spam(self):
        print(1)

class B(A):
    def spam(self):
        print(2)
        super().spam()

B().spam()

OUTPUT:
2
1
","class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.color)
fido.bark()
OUTPUT
brown
Woof!
----------------------------------
class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Cat(""Fido"", ""white"")
print(fido.color)
fido.purr()
OUTPUT
white
Purr...
----------------------------------
class Wolf: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def bark(self):
        print(""Grr..."")

class Dog(Wolf): # subclass of Wolf
    def bark(self):
        print(""Woof"")

husky = Dog(""Max"", ""grey"")
husky.bark()
OUTPUT
Woof
----------------------------------```python
class Dog(Wolf):
    def bark(self):
        super().bark()  # Calls the `bark` method from `Wolf`
        print(""Woof"")
```

Now, `husky.bark()` would print:
```
Grr...
Woof
```

----------------------------------
class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Dog(""Fido"", ""brown"")
print(fido.color)
fido.bark()
OUTPUT
brown
Woof!

class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

class Cat(Animal):
    def purr(self):
        print(""Purr..."")
        
class Dog(Animal):
    def bark(self):
        print(""Woof!"")

fido = Cat(""Fido"", ""white"")
print(fido.color)
fido.purr()
OUTPUT
white
Purr...
-------------------

class Wolf: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def bark(self):
        print(""Grr..."")

class Dog(Wolf): # subclass of Wolf
    def bark(self):
        print(""Woof"")

husky = Dog(""Max"", ""grey"")
husky.bark()
OUTPUT
Woof

----------------------------------class Vehicle: 
    def horn(self):
        print(""Beep!"")

class Car(Vehicle):
    def __init__(self, name, color):
        self.name = name
        self.color = color

obj = Car(""BMW"", ""red"")
obj.horn()

----------------------------------
class A:
    def method(self):
        print(""A method"")
    
class B(A):
    def another_method(self):
        print(""B method"")
    
class C(B):
    def third_method(self):
        print(""C method"")
    
c = C()
c.method()
c.another_method()
c.third_method()

OUTPUT
A method
B method
C method

-------------------------------------

class A:
def a(self):
print(1)
class B(A):
def a(self):
print(2)

class C(B):
def c(self):
print(3)

c = C()
c.a()

OUTPUT: 2
-------------------------------------
class A:
    def spam(self):
        print(1)

class B(A):
    def spam(self):
        print(2)
        super().spam()

B().spam()

OUTPUT:
2
1
",70
,Magic Methods & Operator Overloading,Magic Methods & Operator Overloading,"Magic methods are special methods which have double underscores at the beginning and end of their names.
They are also known as dunders.
So far, the only one we have encountered is __init__, but there are several others.
They are used to create functionality that can't be represented as a normal method.

One common use of them is operator overloading.
This means defining operators for custom classes that allow operators such as + and * to be used on them.
An example magic method is __add__ for +.

class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)

first = Vector2D(5, 7)
second = Vector2D(3, 9)
result = first + second
print(result.x)
print(result.y)
OUTPUT
8
16

The __add__ method allows for the definition of a custom behavior for the + operator in our class.
As you can see, it adds the corresponding attributes of the objects and returns a new object, containing the result.
Once it's defined, we can add two objects of the class together.

More magic methods for common operators:
__sub__ for -
__mul__ for *
__truediv__ for /
__floordiv__ for //
__mod__ for %
__pow__ for **
__and__ for &
__xor__ for ^
__or__ for |
__lt__ for <
__le__ for <=
__eq__ for ==
__ne__ for !=
__gt__ for >
__ge__ for >=
__len__ for len()
__getitem__ for indexing
__setitem__ for assigning to indexed values
__delitem__ for deleting indexed values
__iter__ for iteration over objects (e.g., in for loops)
__contains__ for in

The expression x + y is translated into x.__add__(y).
However, if x hasn't implemented __add__, and x and y are of different types, then y.__radd__(x) is called.
There are equivalent r methods for all magic methods just mentioned.
In the example below, we defined the division operation for our class SpecialString.

Example:
class SpecialString:
    def __init__(self, cont):
        self.cont = cont

    def __truediv__(self, other):
        line = ""="" * len(other.cont)
        return ""\n"".join([self.cont, line, other.cont])

spam = SpecialString(""spam"")
hello = SpecialString(""Hello world!"")
print(spam / hello)
--------------------------
class BankAccount:
   def __init__(self, balance):
       self.balance = balance
   def __add__(self, other):
       return BankAccount(self.balance + other.balance)
a = BankAccount(1024)
b = BankAccount(42)

result = a + b
print(result.balance)
--------------------------
Python also provides magic methods for comparisons.
__lt__ for <
__le__ for <=
__eq__ for ==
__ne__ for !=
__gt__ for >
__ge__ for >=

If __ne__ is not implemented, it returns the opposite of __eq__.
There are no other relationships between the other operators.

Example:
class SpecialString:
    def __init__(self, cont):
        self.cont = cont

    def __gt__(self, other):
        for index in range(len(other.cont)+1):
            result = other.cont[:index] + "">"" + self.cont
            result += "">"" + other.cont[index:]
            print(result)

spam = SpecialString(""spam"")
eggs = SpecialString(""eggs"")
spam > eggs
--------------------------
There are several magic methods for making classes act like containers.
__len__ for len()
__getitem__ for indexing
__setitem__ for assigning to indexed values
__delitem__ for deleting indexed values
__iter__ for iteration over objects (e.g., in for loops)
__contains__ for in

There are many other magic methods that we won't cover here, such as __call__ for calling objects as functions, and __int__, __str__, and the like, for converting objects to built-in types.

Example:
import random

class VagueList:
    def __init__(self, cont):
        self.cont = cont

    def __getitem__(self, index):
        return self.cont[index + random.randint(-1, 1)]

    def __len__(self):
        return random.randint(0, len(self.cont)*2)

vague_list = VagueList([""A"", ""B"", ""C"", ""D"", ""E""])
print(len(vague_list))
print(len(vague_list))
print(vague_list[2])
print(vague_list[2])

We have overridden the len() function for the class VagueList to return a random number.
The indexing function also returns a random item in a range from the list, based on the expression.
OUTPUT
9
4
B
B
--------------------------",,71
,Object Lifecycle,Object Lifecycle,"The lifecycle of an object is made up of its creation, manipulation, and destruction.

The first stage of the life-cycle of an object is the definition of the class to which it belongs.
The next stage is the instantiation of an instance, when __init__ is called. Memory is allocated to store the instance. Just before this occurs, the __new__ method of the class is called. This is usually overridden only in special cases.
After this has happened, the object is ready to be used.

Other code can then interact with the object, by calling functions on it and accessing its attributes.
Eventually, it will finish being used, and can be destroyed.

When an object is destroyed, the memory allocated to it is freed up, and can be used for other purposes.
Destruction of an object occurs when its reference count reaches zero. Reference count is the number of variables and other elements that refer to an object.
If nothing is referring to it (it has a reference count of zero) nothing can interact with it, so it can be safely deleted.

In some situations, two (or more) objects can be referred to by each other only, and therefore can be deleted as well.
The del statement reduces the reference count of an object by one, and this often leads to its deletion.
The magic method for the del statement is __del__.
The process of deleting objects when they are no longer needed is called garbage collection.
In summary, an object's reference count increases when it is assigned a new name or placed in a container (list, tuple, or dictionary). The object's reference count decreases when it's deleted with del, its reference is reassigned, or its reference goes out of scope. When an object's reference count reaches zero, Python automatically deletes it.
Example:
a = 42  # Create object <42>
b = a  # Increase ref. count  of <42> 
c = [a]  # Increase ref. count  of <42> 

del a  # Decrease ref. count  of <42>
b = 100  # Decrease ref. count  of <42> 
c[0] = -1  # Decrease ref. count  of <42>

Lower level languages like C don't have this kind of automatic memory management.",del instance,72
,Data Hiding,Data Hiding,"A key part of object-oriented programming is encapsulation, which involves packaging of related variables and functions into a single easy-to-use object - an instance of a class.
A related concept is data hiding, which states that implementation details of a class should be hidden, and a clean standard interface be presented for those who want to use the class.
In other programming languages, this is usually done with private methods and attributes, which block external access to certain methods and attributes in a class.

The Python philosophy is slightly different. It is often stated as ""we are all consenting adults here"", meaning that you shouldn't put arbitrary restrictions on accessing parts of a class. Hence there are no ways of enforcing a method or attribute be strictly private.

However, there are ways to discourage people from accessing parts of a class, such as by denoting that it is an implementation detail, and should be used at their own risk.

Weakly private methods and attributes have a single underscore at the beginning.
This signals that they are private, and shouldn't be used by external code. However, it is mostly only a convention, and does not stop external code from accessing them.
Its only actual effect is that from module_name import * won't import variables that start with a single underscore.

Example:
class Queue:
    def __init__(self, contents):
        self._hiddenlist = list(contents)

    def push(self, value):
        self._hiddenlist.insert(0, value)

    def pop(self):
        return self._hiddenlist.pop(-1)

    def __repr__(self):
        return ""Queue({})"".format(self._hiddenlist)

queue = Queue([1, 2, 3])
print(queue)
queue.push(0)
print(queue)
queue.pop()
print(queue)
print(queue._hiddenlist)

In the code above, the attribute _hiddenlist is marked as private, but it can still be accessed in the outside code.
The __repr__ magic method is used for string representation of the instance.

Strongly private methods and attributes have a double underscore at the beginning of their names. This causes their names to be mangled, which means that they can't be accessed from outside the class.
The purpose of this isn't to ensure that they are kept private, but to avoid bugs if there are subclasses that have methods or attributes with the same names.
Name mangled methods can still be accessed externally, but by a different name. The method __privatemethod of class Spam could be accessed externally with _Spam__privatemethod.

Example:
class Spam:
    __egg = 7
    def print_egg(self):
        print(self.__egg)

s = Spam()
s.print_egg()
print(s._Spam__egg)
print(s.__egg)

Basically, Python protects those members by internally changing the name to include the class name.

Excercise:
Data Hiding
You are given a BankAccount class and need to add a deposit() method to it, which adds the given amount to the private balance property.

The code should declare a BankAccount object with an initial balance of 0, take a number from user input, add it to the balance using the deposit() method, and output the object.

Complete the required deposit() method so the code works as expected and produces the required output.

Remember, the methods in a class need to have self as their first parameter, which is used to access the properties.

class BankAccount:
    def __init__(self, balance):
        self._balance = balance

    def __repr__(self):
         return ""Account Balance: {}"".format(self._balance)
    
    def deposit(self, amount):
        self._balance += amount

acc = BankAccount(0)
acc.deposit(int(input()))
print(acc)

","class Queue:
    def __init__(self, contents):
        self._hiddenlist = list(contents)

    def push(self, value):
        self._hiddenlist.insert(0, value)

    def pop(self):
        return self._hiddenlist.pop(-1)

    def __repr__(self):
        return ""Queue({})"".format(self._hiddenlist)

queue = Queue([1, 2, 3])
print(queue)
queue.push(0)
print(queue)
queue.pop()
print(queue)
print(queue._hiddenlist)


class Spam:
    __egg = 7
    def print_egg(self):
        print(self.__egg)

s = Spam()
s.print_egg()
print(s._Spam__egg)
print(s.__egg)



class BankAccount:
    def __init__(self, balance):
        self._balance = balance

    def __repr__(self):
         return ""Account Balance: {}"".format(self._balance)
    
    def deposit(self, amount):
        self._balance += amount

acc = BankAccount(0)
acc.deposit(int(input()))
print(acc)

",73
,Class Methods,Class Methods,"Methods of objects we've looked at so far are called by an instance of a class, which is then passed to the self parameter of the method.
Class methods are different - they are called by a class, which is passed to the cls parameter of the method.
A common use of these are factory methods, which instantiate an instance of a class, using different parameters than those usually passed to the class constructor.
Class methods are marked with a classmethod decorator.

Example:
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

    @classmethod
    def new_square(cls, side_length):
        return cls(side_length, side_length)

square = Rectangle.new_square(5)
print(square.calculate_area())

new_square is a class method and is called on the class, rather than on an instance of the class. It returns a new object of the class cls.

Technically, the parameters self and cls are just conventions; they could be changed to anything else. However, they are universally followed, so it is wise to stick to using them.","class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

    @classmethod
    def new_square(cls, side_length):
        return cls(side_length, side_length)

square = Rectangle.new_square(5)
print(square.calculate_area())",74
,Class Methods static methods,Class Methods static methods,"Static methods are similar to class methods, except they don't receive any additional arguments; they are identical to normal functions that belong to a class.
They are marked with the staticmethod decorator.

Example:
class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings

    @staticmethod
    def validate_topping(topping):
        if topping == ""pineapple"":
            raise ValueError(""No pineapples!"")
        else:
            return True

ingredients = [""cheese"", ""onions"", ""spam""]
if all(Pizza.validate_topping(i) for i in ingredients):
    pizza = Pizza(ingredients)

Static methods behave like plain functions, except for the fact that you can call them from an instance of the class.

Excercise:
Complete the given code to define a static add() method for the Calculator class, which returns the sum of its parameters.
The code takes two numbers as input, and should return their sum using the Calculator class's add() method.
Static methods can be called without creating an object of the class.

class Calculator:
    #your code goes here
    @staticmethod
    def add(a, b):
        return a + b
        
n1 = int(input())
n2 = int(input())

print(Calculator.add(n1, n2))","class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings

    @staticmethod
    def validate_topping(topping):
        if topping == ""pineapple"":
            raise ValueError(""No pineapples!"")
        else:
            return True

ingredients = [""cheese"", ""onions"", ""spam""]
if all(Pizza.validate_topping(i) for i in ingredients):
    pizza = Pizza(ingredients)
----------------------------

class Calculator:
    #your code goes here
    @staticmethod
    def add(a, b):
        return a + b
        
n1 = int(input())
n2 = int(input())

print(Calculator.add(n1, n2))",75
,Properties setter,Properties setter,"Properties provide a way of customizing access to instance attributes.
They are created by putting the property decorator above a method, which means when the instance attribute with the same name as the method is accessed, the method will be called instead.
One common use of a property is to make an attribute read-only.

Example:

class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings

    @property
    def pineapple_allowed(self):
        return False

pizza = Pizza([""cheese"", ""tomato""])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True

OUTPUT
False


Traceback (most recent call last):
  File ""./Playground/file0.py"", line 11, in <module>
    pizza.pineapple_allowed = True
AttributeError: can't set attribute

Properties can also be set by defining setter/getter functions.
The setter function sets the corresponding property's value.
The getter gets the value.
To define a setter, you need to use a decorator of the same name as the property, followed by a dot and the setter keyword.
The same applies to defining getter functions.

Example:
class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings
        self._pineapple_allowed = False

    @property
    def pineapple_allowed(self):
        return self._pineapple_allowed

    @pineapple_allowed.setter
    def pineapple_allowed(self, value):
        if value:
            password = input(""Enter the password: "")
            if password == ""Sw0rdf1sh!"":
                self._pineapple_allowed = value
            else:
                raise ValueError(""Alert! Intruder!"")

pizza = Pizza([""cheese"", ""tomato""])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True
print(pizza.pineapple_allowed)

OUTPUT if the pw is correct:
False
Enter the password: True

OUTPUT if the input is incorrect:
False
Enter the password: 

Traceback (most recent call last):
  File ""./Playground/file0.py"", line 21, in <module>
    pizza.pineapple_allowed = True
  File ""./Playground/file0.py"", line 17, in pineapple_allowed
    raise ValueError(""Alert! Intruder!"")
ValueError: Alert! Intruder!

Excercise:
Complete the provided code by creating an isEven property, which returns True if the value is even, and False if the value is odd.
class Number:
    def __init__(self, num):
        self.value = num

x = Number(int(input()))
print(x.isEven)

Use the modulo operator % to check if the value is even or odd. The value is even if the remainder of dividing it by 2 is 0.

class Number:
    def __init__(self, num):
        self.value = num
        
    #your code goes here
    @property
    def isEven(self):
        if self.value % 2 == 0:
           return True
        else:
            return False
 
x = Number(int(input()))
print(x.isEven)









","class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings

    @property
    def pineapple_allowed(self):
        return False

pizza = Pizza([""cheese"", ""tomato""])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True

OUTPUT
False


Traceback (most recent call last):
  File ""./Playground/file0.py"", line 11, in <module>
    pizza.pineapple_allowed = True
AttributeError: can't set attribute

----------------------
class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings
        self._pineapple_allowed = False

    @property
    def pineapple_allowed(self):
        return self._pineapple_allowed

    @pineapple_allowed.setter
    def pineapple_allowed(self, value):
        if value:
            password = input(""Enter the password: "")
            if password == ""Sw0rdf1sh!"":
                self._pineapple_allowed = value
            else:
                raise ValueError(""Alert! Intruder!"")

pizza = Pizza([""cheese"", ""tomato""])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True
print(pizza.pineapple_allowed)

OUTPUT if the pw is correct:
False
Enter the password: True

OUTPUT if the input is incorrect:
False
Enter the password: 

Traceback (most recent call last):
  File ""./Playground/file0.py"", line 21, in <module>
    pizza.pineapple_allowed = True
  File ""./Playground/file0.py"", line 17, in pineapple_allowed
    raise ValueError(""Alert! Intruder!"")
ValueError: Alert! Intruder!

----------------------
class Number:
    def __init__(self, num):
        self.value = num

x = Number(int(input()))
print(x.isEven)

----------------------

class Number:
    def __init__(self, num):
        self.value = num
        
    #your code goes here
    @property
    def isEven(self):
        if self.value % 2 == 0:
           return True
        else:
            return False
 
x = Number(int(input()))
print(x.isEven)",76
,A Simple Game,A Simple Game,"Object-orientation is very useful when managing different objects and their relations. That is especially useful when you are developing games with different characters and features.

Let's look at an example project that shows how classes are used in game development.
The game to be developed is an old fashioned text-based adventure game.
Below is the function handling input and simple parsing.

def get_input():
  command = input("": "").split()
  verb_word = command[0]
  if verb_word in verb_dict:
    verb = verb_dict[verb_word]
  else:
    print(""Unknown verb {}"". format(verb_word))
    return

  if len(command) >= 2:
    noun_word = command[1]
    print (verb(noun_word))
  else:
    print(verb(""nothing""))

def say(noun):
  return 'You said ""{}""'.format(noun)

verb_dict = {
  ""say"": say,
}

while True:
  get_input()

The code above takes input from the user, and tries to match the first word with a command in verb_dict. If a match is found, the corresponding function is called.

The next step is to use classes to represent game objects.
class GameObject:
  class_name = """"
  desc = """"
  objects = {}

  def __init__(self, name):
    self.name = name
    GameObject.objects[self.class_name] = self

  def get_desc(self):
    return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
  class_name = ""goblin""
  desc = ""A foul creature""

goblin = Goblin(""Gobbly"")

def examine(noun):
  if noun in GameObject.objects:
    return GameObject.objects[noun].get_desc()
  else:
    return ""There is no {} here."".format(noun)

We created a Goblin class, which inherits from the GameObjects class.
We also created a new function examine, which returns the objects description.
Now we can add a new ""examine"" verb to our dictionary and try it out!

verb_dict = {
  ""say"": say,
  ""examine"": examine,
}

Combine this code with the one in our previous example, and run the program.
>>>
: say Hello!
You said ""Hello!""

: examine goblin
goblin
A foul creature

: examine elf
There is no elf here.
:

Combine this code with the one in our previous example, and run the program.

def get_input():
    command = input("": "").split()
    
    if len(command) == 0:
        return

    verb_word = command[0]

    if verb_word in verb_dict:
        verb = verb_dict[verb_word]
    else:
        print(""Unknown verb {}"".format(verb_word))
        return

    if len(command) >= 2:
        noun_word = command[1]
        print(verb(noun_word))
    else:
        print(verb(""nothing""))

def say(noun):
    return 'You said ""{}""'.format(noun)

class GameObject:
    objects = {}

    def __init__(self, name):
        self.name = name
        GameObject.objects[self.class_name] = self

    def get_desc(self):
        return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
    class_name = ""goblin""
    desc = ""A foul creature""

goblin = Goblin(""Gobbly"")

def examine(noun):
    if noun in GameObject.objects:
        return GameObject.objects[noun].get_desc()
    else:
        return ""There is no {} here."".format(noun)

verb_dict = {
    ""say"": say,
    ""examine"": examine,
}

while True:
    get_input()

This code adds more detail to the Goblin class and allows you to fight goblins.

def get_input():
    command = input("": "").split()
    
    if len(command) == 0:
        return

    verb_word = command[0]

    if verb_word in verb_dict:
        verb = verb_dict[verb_word]
    else:
        print(""Unknown verb {}"".format(verb_word))
        return

    if len(command) >= 2:
        noun_word = command[1]
        print(verb(noun_word))
    else:
        print(verb(""nothing""))

def say(noun):
    return 'You said ""{}""'.format(noun)

class GameObject:
    objects = {}

    def __init__(self, name):
        self.name = name
        GameObject.objects[self.class_name] = self

    def get_desc(self):
        return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
    def __init__(self, name):
        self.class_name = ""goblin""
        self.health = 3
        self._desc = ""A foul creature""
        super().__init__(name)

    @property
    def desc(self):
        if self.health >= 3:
            health_line = """"
        elif self.health == 2:
            health_line = ""It has a wound on its knee.""
        elif self.health == 1:
            health_line = ""Its left arm has been cut off!""
        else:
            health_line = ""It is dead.""
        return self._desc + (""\n"" + health_line if health_line else """")

    @desc.setter
    def desc(self, value):
        self._desc = value

def examine(noun):
    if noun in GameObject.objects:
        return GameObject.objects[noun].get_desc()
    else:
        return ""There is no {} here."".format(noun)

def hit(noun):
    if noun in GameObject.objects:
        thing = GameObject.objects[noun]
        if isinstance(thing, Goblin):
            thing.health -= 1
            if thing.health <= 0:
                return ""You killed the goblin!""
            else:
                return ""You hit the {}."".format(thing.class_name)
    return ""There is no {} here."".format(noun)

# Create a goblin instance
goblin = Goblin(""Gobbly"")

verb_dict = {
    ""say"": say,
    ""examine"": examine,
    ""hit"": hit,
}

while True:
    get_input()
","__________________________________
def get_input():
  command = input("": "").split()
  verb_word = command[0]
  if verb_word in verb_dict:
    verb = verb_dict[verb_word]
  else:
    print(""Unknown verb {}"". format(verb_word))
    return

  if len(command) >= 2:
    noun_word = command[1]
    print (verb(noun_word))
  else:
    print(verb(""nothing""))

def say(noun):
  return 'You said ""{}""'.format(noun)

verb_dict = {
  ""say"": say,
}

while True:
  get_input()

__________________________________
class GameObject:
  class_name = """"
  desc = """"
  objects = {}

  def __init__(self, name):
    self.name = name
    GameObject.objects[self.class_name] = self

  def get_desc(self):
    return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
  class_name = ""goblin""
  desc = ""A foul creature""

goblin = Goblin(""Gobbly"")

def examine(noun):
  if noun in GameObject.objects:
    return GameObject.objects[noun].get_desc()
  else:
    return ""There is no {} here."".format(noun)
__________________________________

verb_dict = {
  ""say"": say,
  ""examine"": examine,
}

__________________________________
>>>
: say Hello!
You said ""Hello!""

: examine goblin
goblin
A foul creature

: examine elf
There is no elf here.
:

__________________________________

def get_input():
    command = input("": "").split()
    
    if len(command) == 0:
        return

    verb_word = command[0]

    if verb_word in verb_dict:
        verb = verb_dict[verb_word]
    else:
        print(""Unknown verb {}"".format(verb_word))
        return

    if len(command) >= 2:
        noun_word = command[1]
        print(verb(noun_word))
    else:
        print(verb(""nothing""))

def say(noun):
    return 'You said ""{}""'.format(noun)

class GameObject:
    objects = {}

    def __init__(self, name):
        self.name = name
        GameObject.objects[self.class_name] = self

    def get_desc(self):
        return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
    class_name = ""goblin""
    desc = ""A foul creature""

goblin = Goblin(""Gobbly"")

def examine(noun):
    if noun in GameObject.objects:
        return GameObject.objects[noun].get_desc()
    else:
        return ""There is no {} here."".format(noun)

verb_dict = {
    ""say"": say,
    ""examine"": examine,
}

while True:
    get_input()

__________________________________

def get_input():
    command = input("": "").split()
    
    if len(command) == 0:
        return

    verb_word = command[0]

    if verb_word in verb_dict:
        verb = verb_dict[verb_word]
    else:
        print(""Unknown verb {}"".format(verb_word))
        return

    if len(command) >= 2:
        noun_word = command[1]
        print(verb(noun_word))
    else:
        print(verb(""nothing""))

def say(noun):
    return 'You said ""{}""'.format(noun)

class GameObject:
    objects = {}

    def __init__(self, name):
        self.name = name
        GameObject.objects[self.class_name] = self

    def get_desc(self):
        return self.class_name + ""\n"" + self.desc

class Goblin(GameObject):
    def __init__(self, name):
        self.class_name = ""goblin""
        self.health = 3
        self._desc = ""A foul creature""
        super().__init__(name)

    @property
    def desc(self):
        if self.health >= 3:
            health_line = """"
        elif self.health == 2:
            health_line = ""It has a wound on its knee.""
        elif self.health == 1:
            health_line = ""Its left arm has been cut off!""
        else:
            health_line = ""It is dead.""
        return self._desc + (""\n"" + health_line if health_line else """")

    @desc.setter
    def desc(self, value):
        self._desc = value

def examine(noun):
    if noun in GameObject.objects:
        return GameObject.objects[noun].get_desc()
    else:
        return ""There is no {} here."".format(noun)

def hit(noun):
    if noun in GameObject.objects:
        thing = GameObject.objects[noun]
        if isinstance(thing, Goblin):
            thing.health -= 1
            if thing.health <= 0:
                return ""You killed the goblin!""
            else:
                return ""You hit the {}."".format(thing.class_name)
    return ""There is no {} here."".format(noun)

# Create a goblin instance
goblin = Goblin(""Gobbly"")

verb_dict = {
    ""say"": say,
    ""examine"": examine,
    ""hit"": hit,
}

while True:
    get_input()
",77
,"PRACTICE EXERCISE
Juice Maker","PRACTICE EXERCISE
Juice Maker","You are given a Juice class, which has name and capacity properties.
You need to complete the code to enable and adding of two Juice objects, resulting in a new Juice object with the combined capacity and names of the two juices being added.

For example, if you add an Orange juice with 1.0 capacity and an Apple juice with 2.5 capacity, the resulting juice should have:
name: Orange&Apple
capacity: 3.5

The names have been combined using an & symbol.

Use the __add__ method to define a custom behavior for the + operator and return the resulting object.","class Juice:
    def __init__(self, name, capacity):
        self.name = name
        self.capacity = capacity

    def __str__(self):
        return f""{self.name} ({self.capacity}L)""

    def __add__(self, other):
        new_name = f""{self.name}&{other.name}""
        new_capacity = self.capacity + other.capacity
        return Juice(new_name, new_capacity)

a = Juice('Orange', 1.5)
b = Juice('Apple', 2.0)

result = a + b
print(result)  # Output: Orange&Apple (3.5L)",78
,Regular expressions,Regular expressions,"Regular Expressions
Regular expressions are a powerful tool for various kinds of string manipulation.
They are a domain specific language (DSL) that is present as a library in most modern programming languages, not just Python.
They are useful for two main tasks:
- verifying that strings match a pattern (for instance, that a string has the format of an email address),
- performing substitutions in a string (such as changing all American spellings to British ones).

Domain specific languages are highly specialized mini programming languages.
Regular expressions are a popular example, and SQL (for database manipulation) is another.
Private domain-specific languages are often used for specific industrial purposes.
Regular expressions in Python can be accessed using the re module, which is part of the standard library.
After you've defined a regular expression, the re.match function can be used to determine whether it matches at the beginning of a string.
If it does, match returns an object representing the match, if not, it returns None.
To avoid any confusion while working with regular expressions, we would use raw strings as r""expression"".
Raw strings don't escape anything, which makes use of regular expressions easier.

Example:

import re

pattern = r""spam""

if re.match(pattern, ""spamspamspam""):
    print(""Match"")
else:
    print(""No match"")

OUTPUT
Match

The above example checks if the pattern ""spam"" matches the string and prints ""Match"" if it does.

Here the pattern is a simple word, but there are various characters, which would have special meaning when they are used in a regular expression.

Other functions to match patterns are re.search and re.findall.
The function re.search finds a match of a pattern anywhere in the string.
The function re.findall returns a list of all substrings that match a pattern.

Example:
import re

pattern = r""spam""

if re.match(pattern, ""eggspamsausagespam""):
    print(""Match"")
else:
    print(""No match"")

if re.search(pattern, ""eggspamsausagespam""):
    print(""Match"")
else:
    print(""No match"")

print(re.findall(pattern, ""eggspamsausagespam""))

OUTPUT
No match
Match
['spam', 'spam']

In the example above, the match function did not match the pattern, as it looks at the beginning of the string.
The search function found a match in the string.

The function re.finditer does the same thing as re.findall, except it returns an iterator, rather than a list.

The regex search returns an object with several methods that give details about it.
These methods include group which returns the string matched, start and end which return the start and ending positions of the first match, and span which returns the start and end positions of the first match as a tuple.

Example:

import re

pattern = r""pam""

match = re.search(pattern, ""eggspamsausage"")
if match:
    print(match.group())
    print(match.start())
    print(match.end())
    print(match.span())

OUTPUT
pam
4
7
(4, 7)

One of the most important re methods that use regular expressions is sub.

Syntax:
re.sub(pattern, repl, string, count=0)

This method replaces all occurrences of the pattern in string with repl, substituting all occurrences, unless count provided. This method returns the modified string.

Example:
import re

str = ""My name is David. Hi David.""
pattern = r""David""
newstr = re.sub(pattern, ""Amy"", str)
print(newstr)

OUTPUT
My name is Amy. Hi Amy.

Ecercise:
We need to create a number formatting system for a contacts database.
Create a program that will take the phone number as input, and if the number starts with ""00"", replace them with ""+"".
The number should be printed after formatting.

Sample Input
0014860098

Sample Output
+14860098

Notice that here you shouldn't convert the input string to integer, because you will work with symbols.

import re

#your code goes here
phone = input()

phoneFirstChar = phone[0:2]
phoneRest = phone[2:]
pattern = r""00""
newPhone = re.sub(pattern, ""+"", phoneFirstChar)
print(newPhone + phoneRest)","import re

pattern = r""spam""

if re.match(pattern, ""spamspamspam""):
    print(""Match"")
else:
    print(""No match"")

OUTPUT
Match

---------------------------
import re

pattern = r""spam""

if re.match(pattern, ""eggspamsausagespam""):
    print(""Match"")
else:
    print(""No match"")

if re.search(pattern, ""eggspamsausagespam""):
    print(""Match"")
else:
    print(""No match"")

print(re.findall(pattern, ""eggspamsausagespam""))

OUTPUT
No match
Match
['spam', 'spam']

---------------------------

import re

pattern = r""pam""

match = re.search(pattern, ""eggspamsausage"")
if match:
    print(match.group())
    print(match.start())
    print(match.end())
    print(match.span())

OUTPUT
pam
4
7
(4, 7)

---------------------------

Syntax:
re.sub(pattern, repl, string, count=0)
---------------------------
import re

str = ""My name is David. Hi David.""
pattern = r""David""
newstr = re.sub(pattern, ""Amy"", str)
print(newstr)

OUTPUT
My name is Amy. Hi Amy.
---------------------------

import re

#your code goes here
phone = input()

phoneFirstChar = phone[0:2]
phoneRest = phone[2:]
pattern = r""00""
newPhone = re.sub(pattern, ""+"", phoneFirstChar)
print(newPhone + phoneRest)




",79
,Simple Metacharacters,Simple Metacharacters,"Metacharacters are what make regular expressions more powerful than normal string methods.
They allow you to create regular expressions to represent concepts like ""one or more repetitions of a vowel"".

The existence of metacharacters poses a problem if you want to create a regular expression (or regex) that matches a literal metacharacter, such as ""$"". You can do this by escaping the metacharacters by putting a backslash in front of them.
However, this can cause problems, since backslashes also have an escaping function in normal Python strings. This can mean putting three or four backslashes in a row to do all the escaping.

To avoid this, you can use a raw string, which is a normal string with an ""r"" in front of it. We saw usage of raw strings in the previous lesson.

Raw string: str = r""I am \r\a\w!""

The first metacharacter we will look at is . (dot).
This matches any character, other than a new line.

Example:
import re

pattern = r""gr.y""

if re.match(pattern, ""grey""):
    print(""Match 1"")

if re.match(pattern, ""gray""):
    print(""Match 2"")

if re.match(pattern, ""blue""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

.... means any four character string without newline

The next two metacharacters are ^ and $.
These match the start and end of a string, respectively.

Example:
import re

pattern = r""^gr.y$""

if re.match(pattern, ""grey""):
    print(""Match 1"")

if re.match(pattern, ""gray""):
    print(""Match 2"")

if re.match(pattern, ""stingray""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern ""^gr.y$"" means that the string should start with gr, then follow with any character, except a newline, and end with y.

Excercise:
Write a program that takes a word as input, and outputs ""Match"" if the word has 4 letters, starts with ""m"" and ends with ""e"".
The program should output ""No match"" if these mentioned requirements aren't satisfied.

Sample Input
mine

Sample Output
Match

import re

word = input()
#your code goes here
pattern = r""^m..e$""

if re.match(pattern, word):
    print(""Match"")
else:
    print(""No match"")","Raw string: str = r""I am \r\a\w!""

--------------------

Example:
import re

pattern = r""gr.y""

if re.match(pattern, ""grey""):
    print(""Match 1"")

if re.match(pattern, ""gray""):
    print(""Match 2"")

if re.match(pattern, ""blue""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

.... means any four character string without newline

--------------------
import re

pattern = r""^gr.y$""

if re.match(pattern, ""grey""):
    print(""Match 1"")

if re.match(pattern, ""gray""):
    print(""Match 2"")

if re.match(pattern, ""stingray""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern ""^gr.y$"" means that the string should start with gr, then follow with any character, except a newline, and end with y.

--------------------

import re

word = input()
#your code goes here
pattern = r""^m..e$""

if re.match(pattern, word):
    print(""Match"")
else:
    print(""No match"")",80
,Character Classes,Character Classes,"Character classes provide a way to match only one of a specific set of characters.
A character class is created by putting the characters it matches inside square brackets.

Example:
import re

pattern = r""[aeiou]""

if re.search(pattern, ""grey""):
    print(""Match 1"")

if re.search(pattern, ""qwertyuiop""):
    print(""Match 2"")

if re.search(pattern, ""rhythm myths""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern [aeiou] in the search function matches all strings that contain any one of the characters defined.

[abc][def] woud match any letter out of abc, then any letter from def

Character classes can also match ranges of characters.
Some examples:
The class [a-z] matches any lowercase alphabetic character.
The class [G-P] matches any uppercase character from G to P.
The class [0-9] matches any digit.
Multiple ranges can be included in one class. For example, [A-Za-z] matches a letter of any case.

Example:
import re

pattern = r""[A-Z][A-Z][0-9]""  # The pattern in the example above matches strings that contain two alphabetic uppercase letters followed by a digit.

if re.search(pattern, ""LS8""):
    print(""Match 1"")

if re.search(pattern, ""E3""):
    print(""Match 2"")

if re.search(pattern, ""1ab""):
    print(""Match 3"")

OUTPUT
Match 1

[1-5][0-9] match any two digit number from 10 to 59

Place a ^ at the start of a character class to invert it.
This causes it to match any character other than the ones included.
Other metacharacters such as $ and ., have no meaning within character classes.
The metacharacter ^ has no meaning unless it is the first character in a class.

Example:
import re

pattern = r""[^A-Z]""

if re.search(pattern, ""this is all quiet""):
    print(""Match 1"")

if re.search(pattern, ""AbCdEfG123""):
    print(""Match 2"")

if re.search(pattern, ""THISISALLSHOUTING""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern [^A-Z] excludes uppercase strings.
Note, that the ^ should be inside the brackets to invert the character class.

Excercise:
All the products in online shop have their own ID. Every ID consists of 4 symbols:
The first symbol: an uppercase character
The second symbol: an uppercase character
The third symbol: a digit
The forth symbol: a digit

Write a program for a search tool, that will take the ID as input and output ""Searching"" if the format is correct, and ""Wrong format"", if it's not.

Sample Input
LG17

Sample Output
Searching

import re
Id = input()

#your code goes here
pattern = r""[A-Z][A-Z][0-9][0-9]$""

if re.search(pattern, Id):
    print(""Searching"")
else:
    print(""Wrong format"")","import re

pattern = r""[aeiou]""

if re.search(pattern, ""grey""):
    print(""Match 1"")

if re.search(pattern, ""qwertyuiop""):
    print(""Match 2"")

if re.search(pattern, ""rhythm myths""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern [aeiou] in the search function matches all strings that contain any one of the characters defined.

[abc][def] woud match any letter out of abc, then any letter from def

Character classes can also match ranges of characters.
Some examples:
The class [a-z] matches any lowercase alphabetic character.
The class [G-P] matches any uppercase character from G to P.
The class [0-9] matches any digit.
Multiple ranges can be included in one class. For example, [A-Za-z] matches a letter of any case.

Example:
import re

pattern = r""[A-Z][A-Z][0-9]""  # The pattern in the example above matches strings that contain two alphabetic uppercase letters followed by a digit.

if re.search(pattern, ""LS8""):
    print(""Match 1"")

if re.search(pattern, ""E3""):
    print(""Match 2"")

if re.search(pattern, ""1ab""):
    print(""Match 3"")

OUTPUT
Match 1

[1-5][0-9] match any two digit number from 10 to 59

Place a ^ at the start of a character class to invert it.
-----------------------------------
import re

pattern = r""[^A-Z]""

if re.search(pattern, ""this is all quiet""):
    print(""Match 1"")

if re.search(pattern, ""AbCdEfG123""):
    print(""Match 2"")

if re.search(pattern, ""THISISALLSHOUTING""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The pattern [^A-Z] excludes uppercase strings.
Note, that the ^ should be inside the brackets to invert the character class.
-----------------------------------

import re
Id = input()

#your code goes here
pattern = r""[A-Z][A-Z][0-9][0-9]$""

if re.search(pattern, Id):
    print(""Searching"")
else:
    print(""Wrong format"")



",81
,more metacharacters,more metacharacters,"Some more metacharacters are *, +, ?, { and }.
These specify numbers of repetitions.
The metacharacter * means ""zero or more repetitions of the previous thing"". It tries to match as many repetitions as possible. The ""previous thing"" can be a single character, a class, or a group of characters in parentheses.

Example:
import re

pattern = r""egg(spam)*""

if re.match(pattern, ""egg""):
    print(""Match 1"")

if re.match(pattern, ""eggspamspamegg""):
    print(""Match 2"")

if re.match(pattern, ""spam""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

The example above matches strings that start with ""egg"" and follow with zero or more ""spam""s.

[a^]* means zero or more repetitions of ""a"" or ""^""

The metacharacter + is very similar to *, except it means ""one or more repetitions"", as opposed to ""zero or more repetitions"".

Example:
import re

pattern = r""g+""

if re.match(pattern, ""g""):
    print(""Match 1"")

if re.match(pattern, ""gggggggggggggg""):
    print(""Match 2"")

if re.match(pattern, ""abc""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

To summarize:
* matches 0 or more occurrences of the preceding expression.
+ matches 1 or more occurrence of the preceding expression.

The pattern that matches strings that contains one or more 42s:
r""(42)+$""

The metacharacter ? means ""zero or one repetitions"".

Example:
import re

pattern = r""ice(-)?cream""

if re.match(pattern, ""ice-cream""):
    print(""Match 1"")

if re.match(pattern, ""icecream""):
    print(""Match 2"")

if re.match(pattern, ""sausages""):
    print(""Match 3"")

if re.match(pattern, ""ice--ice""):
    print(""Match 4"")

OUTPUT
Match 1
Match 2

pattern to match both ""color"" and ""colour"" : pattern = r""colo(u)?r""

Curly braces can be used to represent the number of repetitions between two numbers.
The regex {x,y} means ""between x and y repetitions of something"".
Hence {0,1} is the same thing as ?.
If the first number is missing, it is taken to be zero. If the second number is missing, it is taken to be infinity.

Example:
import re

pattern = r""9{1,3}$""

if re.match(pattern, ""9""):
    print(""Match 1"")

if re.match(pattern, ""999""):
    print(""Match 2"")

if re.match(pattern, ""9999""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

""9{1,3}$"" matches string that have 1 to 3 nines.

Excercise:
Let's imagine we are creating our own authentication system.
Create a program that takes a password as input and returns ""Password created"" if
- it has at least one uppercase character
- it has at least one number

The Program should output ""Wrong format"" if requirements above are not met.
Use metacharacter * that means zero or more repetitions.

Sample Input
Hal44gb8

Sample Output
Password created

import re
password = input()
pattern = r""\w*[A-Z]\w*[0-9]\w*""

if re.match(pattern, password):
    print(""Password created"")
else:
    print(""Wrong format"")


{1,} == +","import re

pattern = r""egg(spam)*""

if re.match(pattern, ""egg""):
    print(""Match 1"")

if re.match(pattern, ""eggspamspamegg""):
    print(""Match 2"")

if re.match(pattern, ""spam""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

-------------------------------

[a^]* means zero or more repetitions of ""a"" or ""^""

The metacharacter + is very similar to *, except it means ""one or more repetitions"", as opposed to ""zero or more repetitions"".
-------------------------------
import re

pattern = r""g+""

if re.match(pattern, ""g""):
    print(""Match 1"")

if re.match(pattern, ""gggggggggggggg""):
    print(""Match 2"")

if re.match(pattern, ""abc""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

To summarize:
* matches 0 or more occurrences of the preceding expression.
+ matches 1 or more occurrence of the preceding expression.

The pattern that matches strings that contains one or more 42s:
r""(42)+$""

The metacharacter ? means ""zero or one repetitions"".

-------------------------------
import re

pattern = r""ice(-)?cream""

if re.match(pattern, ""ice-cream""):
    print(""Match 1"")

if re.match(pattern, ""icecream""):
    print(""Match 2"")

if re.match(pattern, ""sausages""):
    print(""Match 3"")

if re.match(pattern, ""ice--ice""):
    print(""Match 4"")

OUTPUT
Match 1
Match 2

pattern to match both ""color"" and ""colour"" : pattern = r""colo(u)?r""
-------------------------------
import re

pattern = r""9{1,3}$""

if re.match(pattern, ""9""):
    print(""Match 1"")

if re.match(pattern, ""999""):
    print(""Match 2"")

if re.match(pattern, ""9999""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2

""9{1,3}$"" matches string that have 1 to 3 nines.

-------------------------------

import re
password = input()
pattern = r""\w*[A-Z]\w*[0-9]\w*""

if re.match(pattern, password):
    print(""Password created"")
else:
    print(""Wrong format"")


{1,} == +",82
,Groups,Groups,"A group can be created by surrounding part of a regular expression with parentheses.
This means that a group can be given as an argument to metacharacters such as * and ?.

Example:
import re

pattern = r""egg(spam)*""

if re.match(pattern, ""egg""):
    print(""Match 1"")

if re.match(pattern, ""eggspamspamspamegg""):
    print(""Match 2"")

if re.match(pattern, ""spam""):
    print(""Match 3"")

OUTPUT
Match 1
Match 2
(spam) represents a group in the example pattern shown above.

What would '([^aeiou][aeiou][^aeiou])+' match?
One or more repetitions of non-vowel, a vowel and a non-vowel

The content of groups in a match can be accessed using the group function.
A call of group(0) or group() returns the whole match.
A call of group(n), where n is greater than 0, returns the nth group from the left.
The method groups() returns all groups up from 1.

Example:
import re

pattern = r""a(bc)(de)(f(g)h)i""

match = re.match(pattern, ""abcdefghijklmnop"")
if match:
    print(match.group())
    print(match.group(0))
    print(match.group(1))
    print(match.group(2))
    print(match.groups())

OUTPUT
abcdefghi
abcdefghi
bc
de
('bc', 'de', 'fgh', 'g')

Groups can be nested

What would group(3) be of a match of 1(23)(4(56)78)9(0)?
56
Your answer is correct because `group(3)` refers to the third set of parentheses in the regex match. In your example, `(4(56))` is the second group, and within that, `(56)` is the third group. Thus, `group(3)` correctly returns `56`. 

There are several kinds of special groups.
Two useful ones are named groups and non-capturing groups.
Named groups have the format (?P<name>...), where name is the name of the group, and ... is the content. They behave exactly the same as normal groups, except they can be accessed by group(name) in addition to its number.
Non-capturing groups have the format (?:...). They are not accessible by the group method, so they can be added to an existing regular expression without breaking the numbering.

Example:
import re

pattern = r""(?P<first>abc)(?:def)(ghi)""

match = re.match(pattern, ""abcdefghi"")
if match:
    print(match.group(""first""))
    print(match.groups())

OUTPUT
abc
('abc', 'ghi')

What would be the result of len(match.groups()) of a match of (a)(b(?:c)(d)(?:e))?
3
The `match.groups()` method returns a tuple of all captured groups, including both regular and non-capturing groups.

Another important metacharacter is |.
This means ""or"", so red|blue matches either ""red"" or ""blue"".

Example:
import re

pattern = r""gr(a|e)y""

match = re.match(pattern, ""gray"")
if match:
    print (""Match 1"")

match = re.match(pattern, ""grey"")
if match:
    print (""Match 2"")    

match = re.match(pattern, ""griy"")
if match:
     print (""Match 3"")


OUTPUT
Match 1
Match 2",,83
,Special Sequences,Special Sequences,"There are various special sequences you can use in regular expressions. They are written as a backslash followed by another character.
One useful special sequence is a backslash and a number between 1 and 99, e.g., \1 or \17. This matches the expression of the group of that number.

Example:
import re

pattern = r""(.+) \1""

match = re.match(pattern, ""word word"")
if match:
    print (""Match 1"")

match = re.match(pattern, ""?! ?!"")
if match:
    print (""Match 2"")    

match = re.match(pattern, ""abc cde"")
if match:
    print (""Match 3"")

OUTPUT
Match 1
Match 2

Note, that ""(.+) \1"" is not the same as ""(.+) (.+)"", because \1 refers to the first group's subexpression, which is the matched expression itself, and not the regex pattern.

What would (abc|xyz)\1 match?
""abc"" or ""xyz"", followed by the same thing

More useful special sequences are \d, \s, and \w.
These match digits, whitespace, and word characters respectively.
In ASCII mode they are equivalent to [0-9], [ \t\n\r\f\v], and [a-zA-Z0-9_].
In Unicode mode they match certain other characters, as well. For instance, \w matches letters with accents.
Versions of these special sequences with upper case letters - \D, \S, and \W - mean the opposite to the lower-case versions. For instance, \D matches anything that isn't a digit.

Example:
import re

pattern = r""(\D+\d)""

match = re.match(pattern, ""Hi 999!"")
if match:
    print(""Match 1"")

match = re.match(pattern, ""1, 23, 456!"")
if match:
    print(""Match 2"")

match = re.match(pattern, "" ! $?"")
if match:
    print(""Match 3"")

OUTPUT
Match 1

(\D+\d) matches one or more non-digits followed by a digit.

Excercise:
You are a social media marketing specialist doing research on social networks.
Write a program for your research that will take text as input and output all of the hashtags in it separately.

Sample Input
No #pressure, no #diamonds

Sample Output
#pressure
#diamonds

Remember that the re.findall() method returns a list of all substrings that match a pattern. So, you can use the regex r""#\w+"" to find all words that start with a hashtag and output them on separate lines.

import re

text = input()
match = re.findall(r""#\w+"", text)
if match:
    print(""\n"".join(match))

Which pattern would NOT match ""123!456!"" ?
(\D+\s?)+
But it matches with:
[1-6!] and
(\d*\W)+

Additional special sequences are \A, \Z, and \b.
The sequences \A and \Z match the beginning and end of a string, respectively.
The sequence \b matches the empty string between \w and \W characters, or \w characters and the beginning or end of the string. Informally, it represents the boundary between words.
The sequence \B matches the empty string anywhere else.

Example:
import re

pattern = r""\b(cat)\b""

match = re.search(pattern, ""The cat sat!"")
if match:
    print (""Match 1"")

match = re.search(pattern, ""We s>cat<tered?"")
if match:
    print (""Match 2"")

match = re.search(pattern, ""We scattered."")
if match:
    print (""Match 3"")

OUTPUT
Match 1
Match 2

""\b(cat)\b"" basically matches the word ""cat"" surrounded by word boundaries.

Which pattern would match 'SPAM!' in a search?
\AS...\b.\Z",,84
,Email Extraction,Email Extraction,"To demonstrate a sample usage of regular expressions, lets create a program to extract email addresses from a string.
Suppose we have a text that contains an email address:

str = ""Please contact info@sololearn.com for assistance""

Our goal is to extract the substring ""info@sololearn.com"".
A basic email address consists of a word and may include dots or dashes. This is followed by the @ sign and the domain name (the name, a dot, and the domain name suffix).
This is the basis for building our regular expression.

pattern = r""([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)""

[\w\.-]+ matches one or more word character, dot or dash.
The regex above says that the string should contain a word (with dots and dashes allowed), followed by the @ sign, then another similar word, then a dot and another word.

Our regex contains three groups:
1 - first part of the email address.
2 - domain name without the suffix.
3 - the domain suffix.

Putting it all together:

import re

pattern = r""([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)""
str = ""Please contact info@sololearn.com for assistance""

match = re.search(pattern, str)
if match:
    print(match.group())

OUTPUT
info@sololearn.com

In case the string contains multiple email addresses, we could use the re.findall method instead of re.search, to extract all email addresses.

The regex in this example is for demonstration purposes only.
A much more complex regex is required to fully validate an email address.",,85
,Phone Number Validator,Phone Number Validator,"You are given a number input, and need to check if it is a valid phone number.
A valid phone number has exactly 8 digits and starts with 1, 8 or 9.
Output ""Valid"" if the number is valid and ""Invalid"", if it is not.

Sample Input
81239870

Sample Output
Valid

You can use a regular expression to check if the input matches the given pattern.

import re

def is_valid_phone_number(number):
    pattern = r'^[189]\d{7}$'  # Starts with 1, 8, or 9, followed by 7 digits
    if re.fullmatch(pattern, number):
        return ""Valid""
    else:
        return ""Invalid""

# Sample Input
number = input().strip()
print(is_valid_phone_number(number))",,86
,The Zen of Python,The Zen of Python,"Writing programs that actually do what they are supposed to do is just one component of being a good Python programmer.
It's also important to write clean code that is easily understood, even weeks after you've written it.

One way of doing this is to follow the Zen of Python, a somewhat tongue-in-cheek set of principles that serves as a guide to programming the Pythoneer way. Use the following code to access the Zen of Python.


import this

OUTPUT
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!


Some lines in the Zen of Python may need more explanation.
Explicit is better than implicit: It is best to spell out exactly what your code is doing. This is why adding a numeric string to an integer requires explicit conversion, rather than having it happen behind the scenes, as it does in other languages.
Flat is better than nested: Heavily nested structures (lists of lists, of lists, and on and on…) should be avoided.
Errors should never pass silently: In general, when an error occurs, you should output some sort of error message, rather than ignoring it.

There are 20 principles in the Zen of Python, but only 19 lines of text.
The 20th principle is a matter of opinion, but our interpretation is that the blank line means ""Use whitespace"".

The line ""There should be one - and preferably only one - obvious way to do it"" references and contradicts the Perl language philosophy that there should be more than one way to do it.
",,87
,PEP,PEP,"Python Enhancement Proposals (PEP) are suggestions for improvements to the language, made by experienced Python developers.
PEP 8 is a style guide on the subject of writing readable code. It contains a number of guidelines in reference to variable names, which are summarized here:
- modules should have short, all-lowercase names;
- class names should be in the CapWords style;
- most variables and function names should be lowercase_with_underscores;
- constants (variables that never change value) should be CAPS_WITH_UNDERSCORES;
- names that would clash with Python keywords (such as 'class' or 'if') should have a trailing underscore.

PEP 8 also recommends using spaces around operators and after commas to increase readability.

However, whitespace should not be overused. For instance, avoid having any space directly inside any type of brackets.

Other PEP 8 suggestions include the following:
- lines shouldn't be longer than 80 characters;
- 'from module import *' should be avoided;
- there should only be one statement per line.

It also suggests that you use spaces, rather than tabs, to indent. However, to some extent, this is a matter of personal preference. If you use spaces, only use 4 per line. It's more important to choose one and stick to it.

The most important advice in the PEP is to ignore it when it makes sense to do so. Don't bother with following PEP suggestions when it would cause your code to be less readable; inconsistent with the surrounding code; or not backwards compatible.
However, by and large, following PEP 8 will greatly enhance the quality of your code.

Some other notable PEPs that cover code style:
PEP 20: The Zen of Python
PEP 257: Style Conventions for Docstrings",,88
,Function Arguments,Function Arguments,"Python allows to have function with varying number of arguments.
Using *args as a function parameter enables you to pass an arbitrary number of arguments to that function. The arguments are then accessible as the tuple args in the body of the function.

Example:
def function(named_arg, *args):
    print(named_arg)
    print(args)

function(1, 2, 3, 4, 5)

OUTPUT
1
(2, 3, 4, 5)

The function is called with the arguments 1,2,3,4,5.
In this call, 1  will be assigned to named_argument, and the remaining arguments 2,3,4,5 will be captured in the args tuple.

Excercise:
Given a function that takes 2 arguments and returns their sum.
But we get an error when we want to sum more than 2 numbers. Change the function and complete the code so that the function sums as many numbers as are input.

*args are accessible as the tuple args in the body of the function, so you can iterate through its items.

def adder(x, *args):
    print(x + sum(args))

adder(2, 3)
adder(2, 3, 4)
adder(1, 2, 3, 4, 5)

The parameter *args must come after the named parameters to a function.
The name args is just a convention; you can choose to use another.

Named parameters to a function can be made optional by giving them a default value.
These must come after named parameters without a default value.

Example:
def function(x, y, food=""spam""):
    print(food)

function(1, 2)
function(3, 4, ""egg"")

OUTPUT
spam
egg

In case the argument is passed in, the default value is ignored.
If the argument is not passed in, the default value is used.


**kwargs (standing for keyword arguments) allows you to handle named arguments that you have not defined in advance.
The keyword arguments return a dictionary in which the keys are the argument names, and the values are the argument values.

Example:
def my_func(x, y=7, *args, **kwargs):
    print(kwargs)

my_func(2, 3, 4, 5, 6, a=7, b=8)

OUTPUT
{'a': 7, 'b': 8}

a and b are the names of the arguments that we passed to the function call.

The arguments returned by **kwargs are not included in *args.

",*args **kwargs,89
,Tuple Unpacking,Tuple Unpacking,"Tuple unpacking allows you to assign each item in an iterable (often a tuple) to a variable.

Example:
numbers = (1, 2, 3)
a, b, c = numbers
print(a)
print(b)
print(c)

OUTPUT
1
2
3

This can be also used to swap variables by doing a, b = b, a , since b, a on the right hand side forms the tuple (b, a) which is then unpacked.

A variable that is prefaced with an asterisk (*) takes all values from the iterable that are left over from the other variables.

Example:
a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)
print(b)
print(c)
print(d)

OUTPUT
1
2
[3, 4, 5, 6, 7, 8]
9

What is the output of this code?
a, b, c, d, *e, f, g = range(20)
print(len(e))

A: 14
",,90
,Ternary Operator,Ternary Operator,"Ternary Operator

Conditional expressions provide the functionality of if statements while using less code. They shouldn't be overused, as they can easily reduce readability, but they are often useful when assigning variables.
Conditional expressions are also known as applications of the ternary operator.

Example:
status  = 1
msg = ""Logout"" if status == 1 else ""Login""

print(msg)

OUTPUT
1

The ternary operator is so called because, unlike most operators, it takes three arguments.

Excercise:
You are given a program for a bank card withdrawal system: it takes the account and the amount that the user wants to withdraw, then outputs the remaining money. If the requested cash is greater than the balance, the program outputs ""Error"".
The bank wants to set a minimal value of $500 for withdrawal. Modernize the program so that it will output the same ""Error"" if the requested money is less than $500.

Sample Input
4500
300

Sample Output
Error

As with other operators, you can chain multiple conditions with the ternary operator.

balance = int(input())
to_cash = int(input())

minimal = 500
money_left = balance - to_cash if (balance - to_cash > 0 and to_cash >= minimal) else ""Error""

print(money_left)
",,91
,More on else Statements,More on else Statements,"The else statement is most commonly used along with the if statement, but it can also follow a for or while loop, which gives it a different meaning.
With the for or while loop, the code within it is called if the loop finishes normally (when a break statement does not cause an exit from the loop).

Example:
for i in range(10):
    if i == 999:
        break
else:
    print(""Unbroken 1"")

for i in range(10):
    if i == 5:
        break
else:
    print(""Unbroken 2"")

OUTPUT
Unbroken 1

Excercise:
The carousel is designed for 3 people who are each at least 16 years old.
You are given a program that takes all 3 passengers' ages as inputs and inserts them in a list. Complete the program so that if it finds a value less than 16, it breaks the loop and outputs ""Too young!"".
If the age requirement is satisfied, the program outputs ""Get ready!"".

Sample Input
18
26
19

Sample Output
Get ready!

With the while loop, the code within the else block is called if the loop finishes normally, so that's where you need to output the ""Get ready!"" message.

ages = []
i = 0

while i < 3:
    age = int(input())
    ages.append(age)
    if min(ages) < 16:
         print(""Too young!"")
         break
    i += 1
else:
    print(""Get ready!"")

ELSE:
The else statement can also be used with try/except statements.
In this case, the code within it is only executed if no error occurs in the try statement.

Example:
try:
    print(1)
except ZeroDivisionError:
    print(2)
else:
    print(3)

try:
    print(1/0)
except ZeroDivisionError:
    print(4)
else:
    print(5)

OUTPUT
1
3
4


",,92
,__main__,__main__,"Most Python code is either a module to be imported, or a script that does something.
However, sometimes it is useful to make a file that can be both imported as a module and run as a script.
To do this, place script code inside if __name__ == ""__main__"".
This ensures that it won't be run if the file is imported.

Example:
def function():
    print(""This is a module function"")

if __name__==""__main__"":
    print(""This is a script"")

OUTPUT
This is a script

When the Python interpreter reads a source file, it executes all of the code it finds in the file. Before executing the code, it defines a few special variables.
For example, if the Python interpreter is running that module (the source file) as the main program, it sets the special __name__ variable to have a value ""__main__"". If this file is being imported from another module, __name__ will be set to the module's name.

If we save the code from our previous example as a file called sololearn.py, we can then import it to another script as a module, using the name sololearn.

sololearn.py

def function():
    print(""This is a module function"")

if __name__==""__main__"":
    print(""This is a script"") 

OUTPUT
This is a script

some_script.py
import sololearn
sololearn.function()

Result:
>>>
This is a module function
>>>

Basically, we've created a custom module called sololearn, and then used it in another script.
",,93
,Major 3rd-Party Libraries,Major 3rd-Party Libraries,"A number of third-party modules are available that make it much easier to carry out scientific and mathematical computing with Python.
The module matplotlib allows you to create graphs based on data in Python.
The module NumPy allows for the use of multidimensional arrays that are much faster than the native Python solution of nested lists. It also contains functions to perform mathematical operations such as matrix transformations on the arrays.
The library SciPy contains numerous extensions to the functionality of NumPy.

Python can also be used for game development.
Usually, it is used as a scripting language for games written in other languages, but it can be used to make games by itself.

For 3D games, the library Panda3D can be used. For 2D games, you can use pygame.",,94
,Packages,Packages,"In Python, the term packaging refers to putting modules you have written in a standard format, so that other programmers can install and use them with ease.
This involves use of the modules setuptools and distutils.
The first step in packaging is to organize existing files correctly. Place all of the files you want to put in a library in the same parent directory. This directory should also contain a file called __init__.py, which can be blank but must be present in the directory.
This directory goes into another directory containing the readme and license, as well as an important file called setup.py.

Example directory structure:
SoloLearn/
   LICENSE.txt
   README.txt
   setup.py
   sololearn/
      __init__.py
      sololearn.py
      sololearn2.py

You can place as many script files in the directory as you need.

The next step in packaging is to write the setup.py file.
This contains information necessary to assemble the package so it can be uploaded to PyPI and installed with pip (name, version, etc.).
Example of a setup.py file:

from distutils.core import setup

setup(
   name='SoloLearn', 
   version='0.1dev',
   packages=['sololearn',],
   license='MIT', 
   long_description=open('README.txt').read(),
)

After creating the setup.py file, upload it to PyPI, or use the command line to create a binary distribution (an executable installer).
To build a source distribution, use the command line to navigate to the directory containing setup.py, and run the command 

python setup.py sdist

Run python setup.py bdist or, for Windows, python setup.py bdist_wininst to build a binary distribution.
Use python setup.py register, followed by python setup.py sdist upload to upload a package.

Finally, install a package with python setup.py install.",,95
,Packaging for Users,Packaging for Users,"The previous lesson covered packaging modules for use by other Python programmers. However, many computer users who are not programmers do not have Python installed. Therefore, it is useful to package scripts as executable files for the relevant platform, such as the Windows or Mac operating systems. This is not necessary for Linux, as most Linux users do have Python installed, and are able to run scripts as they are.

For Windows, many tools are available for converting scripts to executables. For example, py2exe, can be used to package a Python script, along with the libraries it requires, into a single executable.
PyInstaller and cx_Freeze serve the same purpose.

For Macs, use py2app, PyInstaller or cx_Freeze.",,96
,Module quiz,Module quiz,"Adding Words
You need to write a function that takes multiple words as its argument and returns a concatenated version of those words separated by dashes (-).
The function should be able to take a varying number of words as the argument.

Sample Input
this
is
great

Sample Output
this-is-great

Recall, using *args as a function parameter enables you to pass an arbitrary number of arguments to that function.


def concatenate(*args):
    return ""-"".join(args)

print(concatenate(""I"", ""love"", ""Python"", ""!""))","def concatenate(*args):
    return ""-"".join(args)

print(concatenate(""I"", ""love"", ""Python"", ""!""))",97
,,,,,98
,,,,,99
,,,,,100
